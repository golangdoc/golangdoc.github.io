<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>types - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<link rel="stylesheet" href="/lib/godoc/jquery.treeview.css">
<script type="text/javascript">window.initFuncs = [];</script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../index.html">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../index.html">Go</a></div>
<a href="types.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">
<a href="../../doc/index.html">Documents</a>
<a href="../index.html">Packages</a>
<a href="../../project/index.html">The Project</a>
<a href="../../help/index.html">Help</a>
<a href="/blog/">Blog</a>

<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>Package types</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "go/types"</code></dd>
			</dl>
			<dl>
			<dd><a href="types.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="types.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="types.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package types declares the data types and implements
the algorithms for type-checking of Go packages. Use
Config.Check to invoke the type checker for a package.
Alternatively, create a new type checker with NewChecker
and invoke it incrementally by calling Checker.Files.
</p>
<p>
Type-checking consists of several interdependent phases:
</p>
<p>
Name resolution maps each identifier (ast.Ident) in the program to the
language object (Object) it denotes.
Use Info.{Defs,Uses,Implicits} for the results of name resolution.
</p>
<p>
Constant folding computes the exact constant value (constant.Value)
for every expression (ast.Expr) that is a compile-time constant.
Use Info.Types[expr].Value for the results of constant folding.
</p>
<p>
Type inference computes the type (Type) of every expression (ast.Expr)
and checks for compliance with the language specification.
Use Info.Types[expr].Type for the results of type inference.
</p>
<p>
For a tutorial, see <a href="https://golang.org/s/types-tutorial">https://golang.org/s/types-tutorial</a>.
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="types.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="types.html#AssertableTo">func AssertableTo(V *Interface, T Type) bool</a></dd>
			
				
				<dd><a href="types.html#AssignableTo">func AssignableTo(V, T Type) bool</a></dd>
			
				
				<dd><a href="types.html#Comparable">func Comparable(T Type) bool</a></dd>
			
				
				<dd><a href="types.html#ConvertibleTo">func ConvertibleTo(V, T Type) bool</a></dd>
			
				
				<dd><a href="types.html#DefPredeclaredTestFuncs">func DefPredeclaredTestFuncs()</a></dd>
			
				
				<dd><a href="types.html#ExprString">func ExprString(x ast.Expr) string</a></dd>
			
				
				<dd><a href="types.html#Id">func Id(pkg *Package, name string) string</a></dd>
			
				
				<dd><a href="types.html#Identical">func Identical(x, y Type) bool</a></dd>
			
				
				<dd><a href="types.html#IdenticalIgnoreTags">func IdenticalIgnoreTags(x, y Type) bool</a></dd>
			
				
				<dd><a href="types.html#Implements">func Implements(V Type, T *Interface) bool</a></dd>
			
				
				<dd><a href="types.html#IsInterface">func IsInterface(typ Type) bool</a></dd>
			
				
				<dd><a href="types.html#ObjectString">func ObjectString(obj Object, qf Qualifier) string</a></dd>
			
				
				<dd><a href="types.html#SelectionString">func SelectionString(s *Selection, qf Qualifier) string</a></dd>
			
				
				<dd><a href="types.html#TypeString">func TypeString(typ Type, qf Qualifier) string</a></dd>
			
				
				<dd><a href="types.html#WriteExpr">func WriteExpr(buf *bytes.Buffer, x ast.Expr)</a></dd>
			
				
				<dd><a href="types.html#WriteSignature">func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)</a></dd>
			
				
				<dd><a href="types.html#WriteType">func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)</a></dd>
			
			
				
				<dd><a href="types.html#Array">type Array</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewArray">func NewArray(elem Type, len int64) *Array</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Array.Elem">func (a *Array) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Array.Len">func (a *Array) Len() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Array.String">func (t *Array) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Array.Underlying">func (t *Array) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#Basic">type Basic</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Basic.Info">func (b *Basic) Info() BasicInfo</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Basic.Kind">func (b *Basic) Kind() BasicKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Basic.Name">func (b *Basic) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Basic.String">func (t *Basic) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Basic.Underlying">func (t *Basic) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#BasicInfo">type BasicInfo</a></dd>
				
				
			
				
				<dd><a href="types.html#BasicKind">type BasicKind</a></dd>
				
				
			
				
				<dd><a href="types.html#Builtin">type Builtin</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.Exported">func (obj *Builtin) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.Id">func (obj *Builtin) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.Name">func (obj *Builtin) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.Parent">func (obj *Builtin) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.Pkg">func (obj *Builtin) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.Pos">func (obj *Builtin) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.String">func (obj *Builtin) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Builtin.Type">func (obj *Builtin) Type() Type</a></dd>
				
			
				
				<dd><a href="types.html#Chan">type Chan</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewChan">func NewChan(dir ChanDir, elem Type) *Chan</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Chan.Dir">func (c *Chan) Dir() ChanDir</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Chan.Elem">func (c *Chan) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Chan.String">func (t *Chan) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Chan.Underlying">func (t *Chan) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#ChanDir">type ChanDir</a></dd>
				
				
			
				
				<dd><a href="types.html#Checker">type Checker</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewChecker">func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Checker.Files">func (check *Checker) Files(files []*ast.File) error</a></dd>
				
			
				
				<dd><a href="types.html#Config">type Config</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Config.Check">func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)</a></dd>
				
			
				
				<dd><a href="types.html#Const">type Const</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewConst">func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Exported">func (obj *Const) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Id">func (obj *Const) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Name">func (obj *Const) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Parent">func (obj *Const) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Pkg">func (obj *Const) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Pos">func (obj *Const) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.String">func (obj *Const) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Type">func (obj *Const) Type() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Const.Val">func (obj *Const) Val() constant.Value</a></dd>
				
			
				
				<dd><a href="types.html#Error">type Error</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Error.Error">func (err Error) Error() string</a></dd>
				
			
				
				<dd><a href="types.html#Func">type Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#MissingMethod">func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewFunc">func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Exported">func (obj *Func) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.FullName">func (obj *Func) FullName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Id">func (obj *Func) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Name">func (obj *Func) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Parent">func (obj *Func) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Pkg">func (obj *Func) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Pos">func (obj *Func) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Scope">func (obj *Func) Scope() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.String">func (obj *Func) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Func.Type">func (obj *Func) Type() Type</a></dd>
				
			
				
				<dd><a href="types.html#ImportMode">type ImportMode</a></dd>
				
				
			
				
				<dd><a href="types.html#Importer">type Importer</a></dd>
				
				
			
				
				<dd><a href="types.html#ImporterFrom">type ImporterFrom</a></dd>
				
				
			
				
				<dd><a href="types.html#Info">type Info</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Info.ObjectOf">func (info *Info) ObjectOf(id *ast.Ident) Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Info.TypeOf">func (info *Info) TypeOf(e ast.Expr) Type</a></dd>
				
			
				
				<dd><a href="types.html#Initializer">type Initializer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Initializer.String">func (init *Initializer) String() string</a></dd>
				
			
				
				<dd><a href="types.html#Interface">type Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewInterface">func NewInterface(methods []*Func, embeddeds []*Named) *Interface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.Complete">func (t *Interface) Complete() *Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.Embedded">func (t *Interface) Embedded(i int) *Named</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.Empty">func (t *Interface) Empty() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.ExplicitMethod">func (t *Interface) ExplicitMethod(i int) *Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.Method">func (t *Interface) Method(i int) *Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.NumEmbeddeds">func (t *Interface) NumEmbeddeds() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.NumExplicitMethods">func (t *Interface) NumExplicitMethods() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.NumMethods">func (t *Interface) NumMethods() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.String">func (t *Interface) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Interface.Underlying">func (t *Interface) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#Label">type Label</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewLabel">func NewLabel(pos token.Pos, pkg *Package, name string) *Label</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.Exported">func (obj *Label) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.Id">func (obj *Label) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.Name">func (obj *Label) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.Parent">func (obj *Label) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.Pkg">func (obj *Label) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.Pos">func (obj *Label) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.String">func (obj *Label) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Label.Type">func (obj *Label) Type() Type</a></dd>
				
			
				
				<dd><a href="types.html#Map">type Map</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewMap">func NewMap(key, elem Type) *Map</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Map.Elem">func (m *Map) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Map.Key">func (m *Map) Key() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Map.String">func (t *Map) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Map.Underlying">func (t *Map) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#MethodSet">type MethodSet</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewMethodSet">func NewMethodSet(T Type) *MethodSet</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#MethodSet.At">func (s *MethodSet) At(i int) *Selection</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#MethodSet.Len">func (s *MethodSet) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#MethodSet.Lookup">func (s *MethodSet) Lookup(pkg *Package, name string) *Selection</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#MethodSet.String">func (s *MethodSet) String() string</a></dd>
				
			
				
				<dd><a href="types.html#Named">type Named</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewNamed">func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Named.AddMethod">func (t *Named) AddMethod(m *Func)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Named.Method">func (t *Named) Method(i int) *Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Named.NumMethods">func (t *Named) NumMethods() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Named.Obj">func (t *Named) Obj() *TypeName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Named.SetUnderlying">func (t *Named) SetUnderlying(underlying Type)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Named.String">func (t *Named) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Named.Underlying">func (t *Named) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#Nil">type Nil</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.Exported">func (obj *Nil) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.Id">func (obj *Nil) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.Name">func (obj *Nil) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.Parent">func (obj *Nil) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.Pkg">func (obj *Nil) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.Pos">func (obj *Nil) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.String">func (obj *Nil) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Nil.Type">func (obj *Nil) Type() Type</a></dd>
				
			
				
				<dd><a href="types.html#Object">type Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#LookupFieldOrMethod">func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)</a></dd>
				
				
			
				
				<dd><a href="types.html#Package">type Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewPackage">func NewPackage(path, name string) *Package</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.Complete">func (pkg *Package) Complete() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.Imports">func (pkg *Package) Imports() []*Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.MarkComplete">func (pkg *Package) MarkComplete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.Name">func (pkg *Package) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.Path">func (pkg *Package) Path() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.Scope">func (pkg *Package) Scope() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.SetImports">func (pkg *Package) SetImports(list []*Package)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.SetName">func (pkg *Package) SetName(name string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Package.String">func (pkg *Package) String() string</a></dd>
				
			
				
				<dd><a href="types.html#PkgName">type PkgName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewPkgName">func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Exported">func (obj *PkgName) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Id">func (obj *PkgName) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Imported">func (obj *PkgName) Imported() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Name">func (obj *PkgName) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Parent">func (obj *PkgName) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Pkg">func (obj *PkgName) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Pos">func (obj *PkgName) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.String">func (obj *PkgName) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#PkgName.Type">func (obj *PkgName) Type() Type</a></dd>
				
			
				
				<dd><a href="types.html#Pointer">type Pointer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewPointer">func NewPointer(elem Type) *Pointer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Pointer.Elem">func (p *Pointer) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Pointer.String">func (t *Pointer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Pointer.Underlying">func (t *Pointer) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#Qualifier">type Qualifier</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#RelativeTo">func RelativeTo(pkg *Package) Qualifier</a></dd>
				
				
			
				
				<dd><a href="types.html#Scope">type Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewScope">func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Child">func (s *Scope) Child(i int) *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Contains">func (s *Scope) Contains(pos token.Pos) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.End">func (s *Scope) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Innermost">func (s *Scope) Innermost(pos token.Pos) *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Insert">func (s *Scope) Insert(obj Object) Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Len">func (s *Scope) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Lookup">func (s *Scope) Lookup(name string) Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.LookupParent">func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Names">func (s *Scope) Names() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.NumChildren">func (s *Scope) NumChildren() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Parent">func (s *Scope) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.Pos">func (s *Scope) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.String">func (s *Scope) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Scope.WriteTo">func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)</a></dd>
				
			
				
				<dd><a href="types.html#Selection">type Selection</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Selection.Index">func (s *Selection) Index() []int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Selection.Indirect">func (s *Selection) Indirect() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Selection.Kind">func (s *Selection) Kind() SelectionKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Selection.Obj">func (s *Selection) Obj() Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Selection.Recv">func (s *Selection) Recv() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Selection.String">func (s *Selection) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Selection.Type">func (s *Selection) Type() Type</a></dd>
				
			
				
				<dd><a href="types.html#SelectionKind">type SelectionKind</a></dd>
				
				
			
				
				<dd><a href="types.html#Signature">type Signature</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewSignature">func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Signature.Params">func (s *Signature) Params() *Tuple</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Signature.Recv">func (s *Signature) Recv() *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Signature.Results">func (s *Signature) Results() *Tuple</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Signature.String">func (t *Signature) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Signature.Underlying">func (t *Signature) Underlying() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Signature.Variadic">func (s *Signature) Variadic() bool</a></dd>
				
			
				
				<dd><a href="types.html#Sizes">type Sizes</a></dd>
				
				
			
				
				<dd><a href="types.html#Slice">type Slice</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewSlice">func NewSlice(elem Type) *Slice</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Slice.Elem">func (s *Slice) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Slice.String">func (t *Slice) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Slice.Underlying">func (t *Slice) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#StdSizes">type StdSizes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#StdSizes.Alignof">func (s *StdSizes) Alignof(T Type) int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#StdSizes.Offsetsof">func (s *StdSizes) Offsetsof(fields []*Var) []int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#StdSizes.Sizeof">func (s *StdSizes) Sizeof(T Type) int64</a></dd>
				
			
				
				<dd><a href="types.html#Struct">type Struct</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewStruct">func NewStruct(fields []*Var, tags []string) *Struct</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Struct.Field">func (s *Struct) Field(i int) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Struct.NumFields">func (s *Struct) NumFields() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Struct.String">func (t *Struct) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Struct.Tag">func (s *Struct) Tag(i int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Struct.Underlying">func (t *Struct) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#Tuple">type Tuple</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewTuple">func NewTuple(x ...*Var) *Tuple</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Tuple.At">func (t *Tuple) At(i int) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Tuple.Len">func (t *Tuple) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Tuple.String">func (t *Tuple) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Tuple.Underlying">func (t *Tuple) Underlying() Type</a></dd>
				
			
				
				<dd><a href="types.html#Type">type Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Default">func Default(typ Type) Type</a></dd>
				
				
			
				
				<dd><a href="types.html#TypeAndValue">type TypeAndValue</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Eval">func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (TypeAndValue, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.Addressable">func (tv TypeAndValue) Addressable() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.Assignable">func (tv TypeAndValue) Assignable() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.HasOk">func (tv TypeAndValue) HasOk() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.IsBuiltin">func (tv TypeAndValue) IsBuiltin() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.IsNil">func (tv TypeAndValue) IsNil() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.IsType">func (tv TypeAndValue) IsType() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.IsValue">func (tv TypeAndValue) IsValue() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeAndValue.IsVoid">func (tv TypeAndValue) IsVoid() bool</a></dd>
				
			
				
				<dd><a href="types.html#TypeName">type TypeName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewTypeName">func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.Exported">func (obj *TypeName) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.Id">func (obj *TypeName) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.Name">func (obj *TypeName) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.Parent">func (obj *TypeName) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.Pkg">func (obj *TypeName) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.Pos">func (obj *TypeName) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.String">func (obj *TypeName) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#TypeName.Type">func (obj *TypeName) Type() Type</a></dd>
				
			
				
				<dd><a href="types.html#Var">type Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewField">func NewField(pos token.Pos, pkg *Package, name string, typ Type, anonymous bool) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewParam">func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#NewVar">func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Anonymous">func (obj *Var) Anonymous() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Exported">func (obj *Var) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Id">func (obj *Var) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.IsField">func (obj *Var) IsField() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Name">func (obj *Var) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Parent">func (obj *Var) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Pkg">func (obj *Var) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Pos">func (obj *Var) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.String">func (obj *Var) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="types.html#Var.Type">func (obj *Var) Type() Type</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h4>Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="types.html#example_Info">Info</a></dd>
			
			<dd><a class="exampleLink" href="types.html#example_MethodSet">MethodSet</a></dd>
			
			<dd><a class="exampleLink" href="types.html#example_Scope">Scope</a></dd>
			
			</dl>
		</div>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="../../src/go/types/api.go.html">api.go</a>
			
				<a href="../../src/go/types/assignments.go.html">assignments.go</a>
			
				<a href="../../src/go/types/builtins.go.html">builtins.go</a>
			
				<a href="../../src/go/types/call.go.html">call.go</a>
			
				<a href="../../src/go/types/check.go.html">check.go</a>
			
				<a href="../../src/go/types/conversions.go.html">conversions.go</a>
			
				<a href="../../src/go/types/decl.go.html">decl.go</a>
			
				<a href="../../src/go/types/errors.go.html">errors.go</a>
			
				<a href="../../src/go/types/eval.go.html">eval.go</a>
			
				<a href="../../src/go/types/expr.go.html">expr.go</a>
			
				<a href="../../src/go/types/exprstring.go.html">exprstring.go</a>
			
				<a href="../../src/go/types/initorder.go.html">initorder.go</a>
			
				<a href="../../src/go/types/labels.go.html">labels.go</a>
			
				<a href="../../src/go/types/lookup.go.html">lookup.go</a>
			
				<a href="../../src/go/types/methodset.go.html">methodset.go</a>
			
				<a href="../../src/go/types/object.go.html">object.go</a>
			
				<a href="../../src/go/types/objset.go.html">objset.go</a>
			
				<a href="../../src/go/types/operand.go.html">operand.go</a>
			
				<a href="../../src/go/types/ordering.go.html">ordering.go</a>
			
				<a href="../../src/go/types/package.go.html">package.go</a>
			
				<a href="../../src/go/types/predicates.go.html">predicates.go</a>
			
				<a href="../../src/go/types/resolver.go.html">resolver.go</a>
			
				<a href="../../src/go/types/return.go.html">return.go</a>
			
				<a href="../../src/go/types/scope.go.html">scope.go</a>
			
				<a href="../../src/go/types/selection.go.html">selection.go</a>
			
				<a href="../../src/go/types/sizes.go.html">sizes.go</a>
			
				<a href="../../src/go/types/stmt.go.html">stmt.go</a>
			
				<a href="../../src/go/types/type.go.html">type.go</a>
			
				<a href="../../src/go/types/typestring.go.html">typestring.go</a>
			
				<a href="../../src/go/types/typexpr.go.html">typexpr.go</a>
			
				<a href="../../src/go/types/universe.go.html">universe.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				
				<pre>var (
    <span id="Universe">Universe</span> *<a href="types.html#Scope">Scope</a>
    <span id="Unsafe">Unsafe</span>   *<a href="types.html#Package">Package</a>
)</pre>
			
				
				<pre>var <span id="Typ">Typ</span> = []*<a href="types.html#Basic">Basic</a>{
    <a href="types.html#Invalid">Invalid</a>: {<a href="types.html#Invalid">Invalid</a>, 0, &#34;invalid type&#34;},

    <a href="types.html#Bool">Bool</a>:          {<a href="types.html#Bool">Bool</a>, <a href="types.html#IsBoolean">IsBoolean</a>, &#34;bool&#34;},
    <a href="types.html#Int">Int</a>:           {<a href="types.html#Int">Int</a>, <a href="types.html#IsInteger">IsInteger</a>, &#34;int&#34;},
    <a href="types.html#Int8">Int8</a>:          {<a href="types.html#Int8">Int8</a>, <a href="types.html#IsInteger">IsInteger</a>, &#34;int8&#34;},
    <a href="types.html#Int16">Int16</a>:         {<a href="types.html#Int16">Int16</a>, <a href="types.html#IsInteger">IsInteger</a>, &#34;int16&#34;},
    <a href="types.html#Int32">Int32</a>:         {<a href="types.html#Int32">Int32</a>, <a href="types.html#IsInteger">IsInteger</a>, &#34;int32&#34;},
    <a href="types.html#Int64">Int64</a>:         {<a href="types.html#Int64">Int64</a>, <a href="types.html#IsInteger">IsInteger</a>, &#34;int64&#34;},
    <a href="types.html#Uint">Uint</a>:          {<a href="types.html#Uint">Uint</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUnsigned">IsUnsigned</a>, &#34;uint&#34;},
    <a href="types.html#Uint8">Uint8</a>:         {<a href="types.html#Uint8">Uint8</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUnsigned">IsUnsigned</a>, &#34;uint8&#34;},
    <a href="types.html#Uint16">Uint16</a>:        {<a href="types.html#Uint16">Uint16</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUnsigned">IsUnsigned</a>, &#34;uint16&#34;},
    <a href="types.html#Uint32">Uint32</a>:        {<a href="types.html#Uint32">Uint32</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUnsigned">IsUnsigned</a>, &#34;uint32&#34;},
    <a href="types.html#Uint64">Uint64</a>:        {<a href="types.html#Uint64">Uint64</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUnsigned">IsUnsigned</a>, &#34;uint64&#34;},
    <a href="types.html#Uintptr">Uintptr</a>:       {<a href="types.html#Uintptr">Uintptr</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUnsigned">IsUnsigned</a>, &#34;uintptr&#34;},
    <a href="types.html#Float32">Float32</a>:       {<a href="types.html#Float32">Float32</a>, <a href="types.html#IsFloat">IsFloat</a>, &#34;float32&#34;},
    <a href="types.html#Float64">Float64</a>:       {<a href="types.html#Float64">Float64</a>, <a href="types.html#IsFloat">IsFloat</a>, &#34;float64&#34;},
    <a href="types.html#Complex64">Complex64</a>:     {<a href="types.html#Complex64">Complex64</a>, <a href="types.html#IsComplex">IsComplex</a>, &#34;complex64&#34;},
    <a href="types.html#Complex128">Complex128</a>:    {<a href="types.html#Complex128">Complex128</a>, <a href="types.html#IsComplex">IsComplex</a>, &#34;complex128&#34;},
    <a href="types.html#String">String</a>:        {<a href="types.html#String">String</a>, <a href="types.html#IsString">IsString</a>, &#34;string&#34;},
    <a href="types.html#UnsafePointer">UnsafePointer</a>: {<a href="types.html#UnsafePointer">UnsafePointer</a>, 0, &#34;Pointer&#34;},

    <a href="types.html#UntypedBool">UntypedBool</a>:    {<a href="types.html#UntypedBool">UntypedBool</a>, <a href="types.html#IsBoolean">IsBoolean</a> | <a href="types.html#IsUntyped">IsUntyped</a>, &#34;untyped bool&#34;},
    <a href="types.html#UntypedInt">UntypedInt</a>:     {<a href="types.html#UntypedInt">UntypedInt</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUntyped">IsUntyped</a>, &#34;untyped int&#34;},
    <a href="types.html#UntypedRune">UntypedRune</a>:    {<a href="types.html#UntypedRune">UntypedRune</a>, <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsUntyped">IsUntyped</a>, &#34;untyped rune&#34;},
    <a href="types.html#UntypedFloat">UntypedFloat</a>:   {<a href="types.html#UntypedFloat">UntypedFloat</a>, <a href="types.html#IsFloat">IsFloat</a> | <a href="types.html#IsUntyped">IsUntyped</a>, &#34;untyped float&#34;},
    <a href="types.html#UntypedComplex">UntypedComplex</a>: {<a href="types.html#UntypedComplex">UntypedComplex</a>, <a href="types.html#IsComplex">IsComplex</a> | <a href="types.html#IsUntyped">IsUntyped</a>, &#34;untyped complex&#34;},
    <a href="types.html#UntypedString">UntypedString</a>:  {<a href="types.html#UntypedString">UntypedString</a>, <a href="types.html#IsString">IsString</a> | <a href="types.html#IsUntyped">IsUntyped</a>, &#34;untyped string&#34;},
    <a href="types.html#UntypedNil">UntypedNil</a>:     {<a href="types.html#UntypedNil">UntypedNil</a>, <a href="types.html#IsUntyped">IsUntyped</a>, &#34;untyped nil&#34;},
}</pre>
			
		
		
			
			
			<h2 id="AssertableTo">func <a href="../../src/go/types/api.go%3Fs=12685:12729.html#L343">AssertableTo</a>
				<a class="permalink" href="types.html#AssertableTo">&#xb6;</a>
			</h2>
			<pre>func AssertableTo(V *<a href="types.html#Interface">Interface</a>, T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
AssertableTo reports whether a value of type V can be asserted to have type T.
</p>

			
			

		
			
			
			<h2 id="AssignableTo">func <a href="../../src/go/types/api.go%3Fs=12869:12902.html#L349">AssignableTo</a>
				<a class="permalink" href="types.html#AssignableTo">&#xb6;</a>
			</h2>
			<pre>func AssignableTo(V, T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
AssignableTo reports whether a value of type V is assignable to a variable of type T.
</p>

			
			

		
			
			
			<h2 id="Comparable">func <a href="../../src/go/types/predicates.go%3Fs=1744:1772.html#L71">Comparable</a>
				<a class="permalink" href="types.html#Comparable">&#xb6;</a>
			</h2>
			<pre>func Comparable(T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
Comparable reports whether values of type T are comparable.
</p>

			
			

		
			
			
			<h2 id="ConvertibleTo">func <a href="../../src/go/types/api.go%3Fs=13107:13141.html#L355">ConvertibleTo</a>
				<a class="permalink" href="types.html#ConvertibleTo">&#xb6;</a>
			</h2>
			<pre>func ConvertibleTo(V, T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
ConvertibleTo reports whether a value of type V is convertible to a value of type T.
</p>

			
			

		
			
			
			<h2 id="DefPredeclaredTestFuncs">func <a href="../../src/go/types/universe.go%3Fs=4742:4772.html#L160">DefPredeclaredTestFuncs</a>
				<a class="permalink" href="types.html#DefPredeclaredTestFuncs">&#xb6;</a>
			</h2>
			<pre>func DefPredeclaredTestFuncs()</pre>
			<p>
DefPredeclaredTestFuncs defines the assert and trace built-ins.
These built-ins are intended for debugging and testing of this
package only.
</p>

			
			

		
			
			
			<h2 id="ExprString">func <a href="../../src/go/types/exprstring.go%3Fs=333:367.html#L5">ExprString</a>
				<a class="permalink" href="types.html#ExprString">&#xb6;</a>
			</h2>
			<pre>func ExprString(x <a href="ast/index.html">ast</a>.<a href="ast/index.html#Expr">Expr</a>) <a href="../builtin/index.html#string">string</a></pre>
			<p>
ExprString returns the (possibly simplified) string representation for x.
</p>

			
			

		
			
			
			<h2 id="Id">func <a href="../../src/go/types/object.go%3Fs=1873:1914.html#L47">Id</a>
				<a class="permalink" href="types.html#Id">&#xb6;</a>
			</h2>
			<pre>func Id(pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>) <a href="../builtin/index.html#string">string</a></pre>
			<p>
Id returns name if it is exported, otherwise it
returns the name qualified with the package path.
</p>

			
			

		
			
			
			<h2 id="Identical">func <a href="../../src/go/types/predicates.go%3Fs=2473:2503.html#L104">Identical</a>
				<a class="permalink" href="types.html#Identical">&#xb6;</a>
			</h2>
			<pre>func Identical(x, y <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
Identical reports whether x and y are identical.
</p>

			
			

		
			
			
			<h2 id="IdenticalIgnoreTags">func <a href="../../src/go/types/predicates.go%3Fs=2626:2666.html#L109">IdenticalIgnoreTags</a>
				<a class="permalink" href="types.html#IdenticalIgnoreTags">&#xb6;</a>
			</h2>
			<pre>func IdenticalIgnoreTags(x, y <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
IdenticalIgnoreTags reports whether x and y are identical if tags are ignored.
</p>

			
			

		
			
			
			<h2 id="Implements">func <a href="../../src/go/types/api.go%3Fs=13315:13357.html#L361">Implements</a>
				<a class="permalink" href="types.html#Implements">&#xb6;</a>
			</h2>
			<pre>func Implements(V <a href="types.html#Type">Type</a>, T *<a href="types.html#Interface">Interface</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
Implements reports whether type V implements interface T.
</p>

			
			

		
			
			
			<h2 id="IsInterface">func <a href="../../src/go/types/predicates.go%3Fs=1593:1624.html#L65">IsInterface</a>
				<a class="permalink" href="types.html#IsInterface">&#xb6;</a>
			</h2>
			<pre>func IsInterface(typ <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#bool">bool</a></pre>
			<p>
IsInterface reports whether typ is an interface type.
</p>

			
			

		
			
			
			<h2 id="ObjectString">func <a href="../../src/go/types/object.go%3Fs=10482:10532.html#L340">ObjectString</a>
				<a class="permalink" href="types.html#ObjectString">&#xb6;</a>
			</h2>
			<pre>func ObjectString(obj <a href="types.html#Object">Object</a>, qf <a href="types.html#Qualifier">Qualifier</a>) <a href="../builtin/index.html#string">string</a></pre>
			<p>
ObjectString returns the string form of obj.
The Qualifier controls the printing of
package-level objects, and may be nil.
</p>

			
			

		
			
			
			<h2 id="SelectionString">func <a href="../../src/go/types/selection.go%3Fs=3594:3649.html#L109">SelectionString</a>
				<a class="permalink" href="types.html#SelectionString">&#xb6;</a>
			</h2>
			<pre>func SelectionString(s *<a href="types.html#Selection">Selection</a>, qf <a href="types.html#Qualifier">Qualifier</a>) <a href="../builtin/index.html#string">string</a></pre>
			<p>
SelectionString returns the string form of s.
The Qualifier controls the printing of
package-level objects, and may be nil.
</p>
<p>
Examples:
</p>
<pre>&#34;field (T) f int&#34;
&#34;method (T) f(X) Y&#34;
&#34;method expr (T) f(X) Y&#34;
</pre>

			
			

		
			
			
			<h2 id="TypeString">func <a href="../../src/go/types/typestring.go%3Fs=2131:2177.html#L54">TypeString</a>
				<a class="permalink" href="types.html#TypeString">&#xb6;</a>
			</h2>
			<pre>func TypeString(typ <a href="types.html#Type">Type</a>, qf <a href="types.html#Qualifier">Qualifier</a>) <a href="../builtin/index.html#string">string</a></pre>
			<p>
TypeString returns the string representation of typ.
The Qualifier controls the printing of
package-level objects, and may be nil.
</p>

			
			

		
			
			
			<h2 id="WriteExpr">func <a href="../../src/go/types/exprstring.go%3Fs=518:563.html#L12">WriteExpr</a>
				<a class="permalink" href="types.html#WriteExpr">&#xb6;</a>
			</h2>
			<pre>func WriteExpr(buf *<a href="../bytes/index.html">bytes</a>.<a href="../bytes/index.html#Buffer">Buffer</a>, x <a href="ast/index.html">ast</a>.<a href="ast/index.html#Expr">Expr</a>)</pre>
			<p>
WriteExpr writes the (possibly simplified) string representation for x to buf.
</p>

			
			

		
			
			
			<h2 id="WriteSignature">func <a href="../../src/go/types/typestring.go%3Fs=7169:7237.html#L264">WriteSignature</a>
				<a class="permalink" href="types.html#WriteSignature">&#xb6;</a>
			</h2>
			<pre>func WriteSignature(buf *<a href="../bytes/index.html">bytes</a>.<a href="../bytes/index.html#Buffer">Buffer</a>, sig *<a href="types.html#Signature">Signature</a>, qf <a href="types.html#Qualifier">Qualifier</a>)</pre>
			<p>
WriteSignature writes the representation of the signature sig to buf,
without a leading &#34;func&#34; keyword.
The Qualifier controls the printing of
package-level objects, and may be nil.
</p>

			
			

		
			
			
			<h2 id="WriteType">func <a href="../../src/go/types/typestring.go%3Fs=2397:2454.html#L63">WriteType</a>
				<a class="permalink" href="types.html#WriteType">&#xb6;</a>
			</h2>
			<pre>func WriteType(buf *<a href="../bytes/index.html">bytes</a>.<a href="../bytes/index.html#Buffer">Buffer</a>, typ <a href="types.html#Type">Type</a>, qf <a href="types.html#Qualifier">Qualifier</a>)</pre>
			<p>
WriteType writes the string representation of typ to buf.
The Qualifier controls the printing of
package-level objects, and may be nil.
</p>

			
			

		
		
			
			
			<h2 id="Array">type <a href="../../src/go/types/type.go%3Fs=1709:1753.html#L84">Array</a>
				<a class="permalink" href="types.html#Array">&#xb6;</a>
			</h2>
			<p>
An Array represents an array type.
</p>

			<pre>type Array struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewArray">func <a href="../../src/go/types/type.go%3Fs=1831:1873.html#L90">NewArray</a>
					<a class="permalink" href="types.html#NewArray">&#xb6;</a>
				</h3>
				<pre>func NewArray(elem <a href="types.html#Type">Type</a>, len <a href="../builtin/index.html#int64">int64</a>) *<a href="types.html#Array">Array</a></pre>
				<p>
NewArray returns a new array type for the given element type and length.
</p>

				
				
			

			
				
				<h3 id="Array.Elem">func (*Array) <a href="../../src/go/types/type.go%3Fs=2029:2056.html#L96">Elem</a>
					<a class="permalink" href="types.html#Array.Elem">&#xb6;</a>
				</h3>
				<pre>func (a *<a href="types.html#Array">Array</a>) Elem() <a href="types.html#Type">Type</a></pre>
				<p>
Elem returns element type of array a.
</p>

				
				
				
			
				
				<h3 id="Array.Len">func (*Array) <a href="../../src/go/types/type.go%3Fs=1942:1969.html#L93">Len</a>
					<a class="permalink" href="types.html#Array.Len">&#xb6;</a>
				</h3>
				<pre>func (a *<a href="types.html#Array">Array</a>) Len() <a href="../builtin/index.html#int64">int64</a></pre>
				<p>
Len returns the length of array a.
</p>

				
				
				
			
				
				<h3 id="Array.String">func (*Array) <a href="../../src/go/types/type.go%3Fs=13387:13418.html#L431">String</a>
					<a class="permalink" href="types.html#Array.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Array">Array</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Array.Underlying">func (*Array) <a href="../../src/go/types/type.go%3Fs=12799:12832.html#L419">Underlying</a>
					<a class="permalink" href="types.html#Array.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Array">Array</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Basic">type <a href="../../src/go/types/type.go%3Fs=1304:1370.html#L68">Basic</a>
				<a class="permalink" href="types.html#Basic">&#xb6;</a>
			</h2>
			<p>
A Basic represents a basic type.
</p>

			<pre>type Basic struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="Basic.Info">func (*Basic) <a href="../../src/go/types/type.go%3Fs=1528:1560.html#L78">Info</a>
					<a class="permalink" href="types.html#Basic.Info">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="types.html#Basic">Basic</a>) Info() <a href="types.html#BasicInfo">BasicInfo</a></pre>
				<p>
Info returns information about properties of basic type b.
</p>

				
				
				
			
				
				<h3 id="Basic.Kind">func (*Basic) <a href="../../src/go/types/type.go%3Fs=1414:1446.html#L75">Kind</a>
					<a class="permalink" href="types.html#Basic.Kind">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="types.html#Basic">Basic</a>) Kind() <a href="types.html#BasicKind">BasicKind</a></pre>
				<p>
Kind returns the kind of basic type b.
</p>

				
				
				
			
				
				<h3 id="Basic.Name">func (*Basic) <a href="../../src/go/types/type.go%3Fs=1622:1651.html#L81">Name</a>
					<a class="permalink" href="types.html#Basic.Name">&#xb6;</a>
				</h3>
				<pre>func (b *<a href="types.html#Basic">Basic</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				<p>
Name returns the name of basic type b.
</p>

				
				
				
			
				
				<h3 id="Basic.String">func (*Basic) <a href="../../src/go/types/type.go%3Fs=13321:13352.html#L430">String</a>
					<a class="permalink" href="types.html#Basic.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Basic">Basic</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Basic.Underlying">func (*Basic) <a href="../../src/go/types/type.go%3Fs=12748:12781.html#L418">Underlying</a>
					<a class="permalink" href="types.html#Basic.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Basic">Basic</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="BasicInfo">type <a href="../../src/go/types/type.go%3Fs=968:986.html#L50">BasicInfo</a>
				<a class="permalink" href="types.html#BasicInfo">&#xb6;</a>
			</h2>
			<p>
BasicInfo is a set of flags describing properties of a basic type.
</p>

			<pre>type BasicInfo <a href="../builtin/index.html#int">int</a></pre>

			
				<p>
Properties of basic types.
</p>

				<pre>const (
    <span id="IsBoolean">IsBoolean</span> <a href="types.html#BasicInfo">BasicInfo</a> = 1 &lt;&lt; <a href="../builtin/index.html#iota">iota</a>
    <span id="IsInteger">IsInteger</span>
    <span id="IsUnsigned">IsUnsigned</span>
    <span id="IsFloat">IsFloat</span>
    <span id="IsComplex">IsComplex</span>
    <span id="IsString">IsString</span>
    <span id="IsUntyped">IsUntyped</span>

    <span id="IsOrdered">IsOrdered</span>   = <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsFloat">IsFloat</a> | <a href="types.html#IsString">IsString</a>
    <span id="IsNumeric">IsNumeric</span>   = <a href="types.html#IsInteger">IsInteger</a> | <a href="types.html#IsFloat">IsFloat</a> | <a href="types.html#IsComplex">IsComplex</a>
    <span id="IsConstType">IsConstType</span> = <a href="types.html#IsBoolean">IsBoolean</a> | <a href="types.html#IsNumeric">IsNumeric</a> | <a href="types.html#IsString">IsString</a>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="BasicKind">type <a href="../../src/go/types/type.go%3Fs=485:503.html#L10">BasicKind</a>
				<a class="permalink" href="types.html#BasicKind">&#xb6;</a>
			</h2>
			<p>
BasicKind describes the kind of basic type.
</p>

			<pre>type BasicKind <a href="../builtin/index.html#int">int</a></pre>

			
				
				<pre>const (
    <span id="Invalid">Invalid</span> <a href="types.html#BasicKind">BasicKind</a> = <a href="../builtin/index.html#iota">iota</a> <span class="comment">// type is invalid</span>

    <span class="comment">// predeclared types</span>
    <span id="Bool">Bool</span>
    <span id="Int">Int</span>
    <span id="Int8">Int8</span>
    <span id="Int16">Int16</span>
    <span id="Int32">Int32</span>
    <span id="Int64">Int64</span>
    <span id="Uint">Uint</span>
    <span id="Uint8">Uint8</span>
    <span id="Uint16">Uint16</span>
    <span id="Uint32">Uint32</span>
    <span id="Uint64">Uint64</span>
    <span id="Uintptr">Uintptr</span>
    <span id="Float32">Float32</span>
    <span id="Float64">Float64</span>
    <span id="Complex64">Complex64</span>
    <span id="Complex128">Complex128</span>
    <span id="String">String</span>
    <span id="UnsafePointer">UnsafePointer</span>

    <span class="comment">// types for untyped values</span>
    <span id="UntypedBool">UntypedBool</span>
    <span id="UntypedInt">UntypedInt</span>
    <span id="UntypedRune">UntypedRune</span>
    <span id="UntypedFloat">UntypedFloat</span>
    <span id="UntypedComplex">UntypedComplex</span>
    <span id="UntypedString">UntypedString</span>
    <span id="UntypedNil">UntypedNil</span>

    <span class="comment">// aliases</span>
    <span id="Byte">Byte</span> = <a href="types.html#Uint8">Uint8</a>
    <span id="Rune">Rune</span> = <a href="types.html#Int32">Int32</a>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Builtin">type <a href="../../src/go/types/object.go%3Fs=8648:8693.html#L242">Builtin</a>
				<a class="permalink" href="types.html#Builtin">&#xb6;</a>
			</h2>
			<p>
A Builtin represents a built-in function.
Builtins don&#39;t have a valid type.
</p>

			<pre>type Builtin struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="Builtin.Exported">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#Builtin.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Id">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#Builtin.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Name">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#Builtin.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Parent">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#Builtin.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Pkg">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#Builtin.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Pos">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#Builtin.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.String">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=11141:11176.html#L353">String</a>
					<a class="permalink" href="types.html#Builtin.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Type">func (*Builtin) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#Builtin.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Builtin">Builtin</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Chan">type <a href="../../src/go/types/type.go%3Fs=10274:10319.html#L341">Chan</a>
				<a class="permalink" href="types.html#Chan">&#xb6;</a>
			</h2>
			<p>
A Chan represents a channel type.
</p>

			<pre>type Chan struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewChan">func <a href="../../src/go/types/type.go%3Fs=10595:10637.html#L357">NewChan</a>
					<a class="permalink" href="types.html#NewChan">&#xb6;</a>
				</h3>
				<pre>func NewChan(dir <a href="types.html#ChanDir">ChanDir</a>, elem <a href="types.html#Type">Type</a>) *<a href="types.html#Chan">Chan</a></pre>
				<p>
NewChan returns a new channel type for the given direction and element type.
</p>

				
				
			

			
				
				<h3 id="Chan.Dir">func (*Chan) <a href="../../src/go/types/type.go%3Fs=10711:10739.html#L362">Dir</a>
					<a class="permalink" href="types.html#Chan.Dir">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="types.html#Chan">Chan</a>) Dir() <a href="types.html#ChanDir">ChanDir</a></pre>
				<p>
Dir returns the direction of channel c.
</p>

				
				
				
			
				
				<h3 id="Chan.Elem">func (*Chan) <a href="../../src/go/types/type.go%3Fs=10805:10831.html#L365">Elem</a>
					<a class="permalink" href="types.html#Chan.Elem">&#xb6;</a>
				</h3>
				<pre>func (c *<a href="types.html#Chan">Chan</a>) Elem() <a href="types.html#Type">Type</a></pre>
				<p>
Elem returns the element type of channel c.
</p>

				
				
				
			
				
				<h3 id="Chan.String">func (*Chan) <a href="../../src/go/types/type.go%3Fs=13915:13945.html#L439">String</a>
					<a class="permalink" href="types.html#Chan.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Chan">Chan</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Chan.Underlying">func (*Chan) <a href="../../src/go/types/type.go%3Fs=13207:13239.html#L427">Underlying</a>
					<a class="permalink" href="types.html#Chan.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Chan">Chan</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ChanDir">type <a href="../../src/go/types/type.go%3Fs=10371:10387.html#L347">ChanDir</a>
				<a class="permalink" href="types.html#ChanDir">&#xb6;</a>
			</h2>
			<p>
A ChanDir value indicates a channel direction.
</p>

			<pre>type ChanDir <a href="../builtin/index.html#int">int</a></pre>

			
				<p>
The direction of a channel is indicated by one of these constants.
</p>

				<pre>const (
    <span id="SendRecv">SendRecv</span> <a href="types.html#ChanDir">ChanDir</a> = <a href="../builtin/index.html#iota">iota</a>
    <span id="SendOnly">SendOnly</span>
    <span id="RecvOnly">RecvOnly</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Checker">type <a href="../../src/go/types/check.go%3Fs=2236:3496.html#L52">Checker</a>
				<a class="permalink" href="types.html#Checker">&#xb6;</a>
			</h2>
			<p>
A Checker maintains the state of the type checker.
It must be created with NewChecker.
</p>

			<pre>type Checker struct {
    *<a href="types.html#Info">Info</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewChecker">func <a href="../../src/go/types/check.go%3Fs=5077:5162.html#L138">NewChecker</a>
					<a class="permalink" href="types.html#NewChecker">&#xb6;</a>
				</h3>
				<pre>func NewChecker(conf *<a href="types.html#Config">Config</a>, fset *<a href="token/index.html">token</a>.<a href="token/index.html#FileSet">FileSet</a>, pkg *<a href="types.html#Package">Package</a>, info *<a href="types.html#Info">Info</a>) *<a href="types.html#Checker">Checker</a></pre>
				<p>
NewChecker returns a new Checker instance for a given package.
Package files may be added incrementally via checker.Files.
</p>

				
				
			

			
				
				<h3 id="Checker.Files">func (*Checker) <a href="../../src/go/types/check.go%3Fs=6655:6707.html#L208">Files</a>
					<a class="permalink" href="types.html#Checker.Files">&#xb6;</a>
				</h3>
				<pre>func (check *<a href="types.html#Checker">Checker</a>) Files(files []*<a href="ast/index.html">ast</a>.<a href="ast/index.html#File">File</a>) <a href="../builtin/index.html#error">error</a></pre>
				<p>
Files checks the provided files as part of the checker&#39;s package.
</p>

				
				
				
			
		
			
			
			<h2 id="Config">type <a href="../../src/go/types/api.go%3Fs=3499:4981.html#L82">Config</a>
				<a class="permalink" href="types.html#Config">&#xb6;</a>
			</h2>
			<p>
A Config specifies the configuration for type checking.
The zero value for Config is a ready-to-use default configuration.
</p>

			<pre>type Config struct {
    <span class="comment">// If IgnoreFuncBodies is set, function bodies are not</span>
    <span class="comment">// type-checked.</span>
<span id="Config.IgnoreFuncBodies"></span>    IgnoreFuncBodies <a href="../builtin/index.html#bool">bool</a>

    <span class="comment">// If FakeImportC is set, `import &#34;C&#34;` (for packages requiring Cgo)</span>
    <span class="comment">// declares an empty &#34;C&#34; package and errors are omitted for qualified</span>
    <span class="comment">// identifiers referring to package C (which won&#39;t find an object).</span>
    <span class="comment">// This feature is intended for the standard library cmd/api tool.</span>
    <span class="comment">//</span>
    <span class="comment">// Caution: Effects may be unpredictable due to follow-up errors.</span>
    <span class="comment">//          Do not use casually!</span>
<span id="Config.FakeImportC"></span>    FakeImportC <a href="../builtin/index.html#bool">bool</a>

    <span class="comment">// If Error != nil, it is called with each error found</span>
    <span class="comment">// during type checking; err has dynamic type Error.</span>
    <span class="comment">// Secondary errors (for instance, to enumerate all types</span>
    <span class="comment">// involved in an invalid recursive type declaration) have</span>
    <span class="comment">// error strings that start with a &#39;\t&#39; character.</span>
    <span class="comment">// If Error == nil, type-checking stops with the first</span>
    <span class="comment">// error found.</span>
<span id="Config.Error"></span>    Error func(err <a href="../builtin/index.html#error">error</a>)

    <span class="comment">// An importer is used to import packages referred to from</span>
    <span class="comment">// import declarations.</span>
    <span class="comment">// If the installed importer implements ImporterFrom, the type</span>
    <span class="comment">// checker calls ImportFrom instead of Import.</span>
    <span class="comment">// The type checker reports an error if an importer is needed</span>
    <span class="comment">// but none was installed.</span>
<span id="Config.Importer"></span>    Importer <a href="types.html#Importer">Importer</a>

    <span class="comment">// If Sizes != nil, it provides the sizing functions for package unsafe.</span>
    <span class="comment">// Otherwise &amp;StdSizes{WordSize: 8, MaxAlign: 8} is used instead.</span>
<span id="Config.Sizes"></span>    Sizes <a href="types.html#Sizes">Sizes</a>

    <span class="comment">// If DisableUnusedImportCheck is set, packages are not checked</span>
    <span class="comment">// for unused imports.</span>
<span id="Config.DisableUnusedImportCheck"></span>    DisableUnusedImportCheck <a href="../builtin/index.html#bool">bool</a>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="Config.Check">func (*Config) <a href="../../src/go/types/api.go%3Fs=12400:12508.html#L337">Check</a>
					<a class="permalink" href="types.html#Config.Check">&#xb6;</a>
				</h3>
				<pre>func (conf *<a href="types.html#Config">Config</a>) Check(path <a href="../builtin/index.html#string">string</a>, fset *<a href="token/index.html">token</a>.<a href="token/index.html#FileSet">FileSet</a>, files []*<a href="ast/index.html">ast</a>.<a href="ast/index.html#File">File</a>, info *<a href="types.html#Info">Info</a>) (*<a href="types.html#Package">Package</a>, <a href="../builtin/index.html#error">error</a>)</pre>
				<p>
Check type-checks a package and returns the resulting package object and
the first error if any. Additionally, if info != nil, Check populates each
of the non-nil maps in the Info struct.
</p>
<p>
The package is marked as complete if no errors occurred, otherwise it is
incomplete. See Config.Error for controlling behavior in the presence of
errors.
</p>
<p>
The package is specified by a list of *ast.Files and corresponding
file set, and the package path the package is identified with.
The clean path must not be empty or dot (&#34;.&#34;).
</p>

				
				
				
			
		
			
			
			<h2 id="Const">type <a href="../../src/go/types/object.go%3Fs=4768:4873.html#L134">Const</a>
				<a class="permalink" href="types.html#Const">&#xb6;</a>
			</h2>
			<p>
A Const represents a declared constant.
</p>

			<pre>type Const struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewConst">func <a href="../../src/go/types/object.go%3Fs=4875:4967.html#L140">NewConst</a>
					<a class="permalink" href="types.html#NewConst">&#xb6;</a>
				</h3>
				<pre>func NewConst(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>, typ <a href="types.html#Type">Type</a>, val <a href="constant/index.html">constant</a>.<a href="constant/index.html#Value">Value</a>) *<a href="types.html#Const">Const</a></pre>
				
				
				
			

			
				
				<h3 id="Const.Exported">func (*Const) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#Const.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Id">func (*Const) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#Const.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Name">func (*Const) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#Const.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Parent">func (*Const) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#Const.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Pkg">func (*Const) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#Const.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Pos">func (*Const) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#Const.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Const.String">func (*Const) <a href="../../src/go/types/object.go%3Fs=10685:10718.html#L347">String</a>
					<a class="permalink" href="types.html#Const.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Type">func (*Const) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#Const.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Val">func (*Const) <a href="../../src/go/types/object.go%3Fs=5050:5088.html#L144">Val</a>
					<a class="permalink" href="types.html#Const.Val">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Const">Const</a>) Val() <a href="constant/index.html">constant</a>.<a href="constant/index.html#Value">Value</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Error">type <a href="../../src/go/types/api.go%3Fs=1537:1742.html#L31">Error</a>
				<a class="permalink" href="types.html#Error">&#xb6;</a>
			</h2>
			<p>
An Error describes a type-checking error; it implements the error interface.
A &#34;soft&#34; error is an error that still permits a valid interpretation of a
package (such as &#34;unused variable&#34;); &#34;hard&#34; errors may lead to unpredictable
behavior if ignored.
</p>

			<pre>type Error struct {
<span id="Error.Fset"></span>    Fset *<a href="token/index.html">token</a>.<a href="token/index.html#FileSet">FileSet</a> <span class="comment">// file set for interpretation of Pos</span>
<span id="Error.Pos"></span>    Pos  <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>      <span class="comment">// error position</span>
<span id="Error.Msg"></span>    Msg  <a href="../builtin/index.html#string">string</a>         <span class="comment">// error message</span>
<span id="Error.Soft"></span>    Soft <a href="../builtin/index.html#bool">bool</a>           <span class="comment">// if set, error is &#34;soft&#34;</span>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="Error.Error">func (Error) <a href="../../src/go/types/api.go%3Fs=1832:1863.html#L40">Error</a>
					<a class="permalink" href="types.html#Error.Error">&#xb6;</a>
				</h3>
				<pre>func (err <a href="types.html#Error">Error</a>) Error() <a href="../builtin/index.html#string">string</a></pre>
				<p>
Error returns an error string formatted as follows:
filename:line:column: message
</p>

				
				
				
			
		
			
			
			<h2 id="Func">type <a href="../../src/go/types/object.go%3Fs=6772:6800.html#L184">Func</a>
				<a class="permalink" href="types.html#Func">&#xb6;</a>
			</h2>
			<p>
A Func represents a declared function, concrete method, or abstract
(interface) method. Its Type() is always a *Signature.
An abstract method may belong to many interfaces due to embedding.
</p>

			<pre>type Func struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="MissingMethod">func <a href="../../src/go/types/lookup.go%3Fs=8488:8572.html#L227">MissingMethod</a>
					<a class="permalink" href="types.html#MissingMethod">&#xb6;</a>
				</h3>
				<pre>func MissingMethod(V <a href="types.html#Type">Type</a>, T *<a href="types.html#Interface">Interface</a>, static <a href="../builtin/index.html#bool">bool</a>) (method *<a href="types.html#Func">Func</a>, wrongType <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>
MissingMethod returns (nil, false) if V implements T, otherwise it
returns a missing method required by T and whether it is missing or
just has the wrong type.
</p>
<p>
For non-interface types V, or if static is set, V implements T if all
methods of T are present in V. Otherwise (V is an interface and static
is not set), MissingMethod only checks that methods of T which are also
present in V have matching types (e.g., for a type assertion x.(T) where
x is of interface type V).
</p>

				
				
			
				
				<h3 id="NewFunc">func <a href="../../src/go/types/object.go%3Fs=6802:6878.html#L188">NewFunc</a>
					<a class="permalink" href="types.html#NewFunc">&#xb6;</a>
				</h3>
				<pre>func NewFunc(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>, sig *<a href="types.html#Signature">Signature</a>) *<a href="types.html#Func">Func</a></pre>
				
				
				
			

			
				
				<h3 id="Func.Exported">func (*Func) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#Func.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Func.FullName">func (*Func) <a href="../../src/go/types/object.go%3Fs=7121:7155.html#L199">FullName</a>
					<a class="permalink" href="types.html#Func.FullName">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) FullName() <a href="../builtin/index.html#string">string</a></pre>
				<p>
FullName returns the package- or receiver-type-qualified name of
function or method obj.
</p>

				
				
				
			
				
				<h3 id="Func.Id">func (*Func) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#Func.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Func.Name">func (*Func) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#Func.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Func.Parent">func (*Func) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#Func.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="Func.Pkg">func (*Func) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#Func.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Func.Pos">func (*Func) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#Func.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Func.Scope">func (*Func) <a href="../../src/go/types/object.go%3Fs=7235:7266.html#L205">Scope</a>
					<a class="permalink" href="types.html#Func.Scope">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Scope() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="Func.String">func (*Func) <a href="../../src/go/types/object.go%3Fs=10913:10945.html#L350">String</a>
					<a class="permalink" href="types.html#Func.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Func.Type">func (*Func) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#Func.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Func">Func</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ImportMode">type <a href="../../src/go/types/api.go%3Fs=2488:2507.html#L58">ImportMode</a>
				<a class="permalink" href="types.html#ImportMode">&#xb6;</a>
			</h2>
			<p>
ImportMode is reserved for future use.
</p>

			<pre>type ImportMode <a href="../builtin/index.html#int">int</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Importer">type <a href="../../src/go/types/api.go%3Fs=2186:2444.html#L49">Importer</a>
				<a class="permalink" href="types.html#Importer">&#xb6;</a>
			</h2>
			<p>
An Importer resolves import paths to Packages.
</p>
<p>
CAUTION: This interface does not support the import of locally
vendored packages. See <a href="https://golang.org/s/go15vendor">https://golang.org/s/go15vendor</a>.
If possible, external implementations should implement ImporterFrom.
</p>

			<pre>type Importer interface {
    <span class="comment">// Import returns the imported package for the given import</span>
    <span class="comment">// path, or an error if the package couldn&#39;t be imported.</span>
    <span class="comment">// Two calls to Import with the same path return the same</span>
    <span class="comment">// package.</span>
    Import(path <a href="../builtin/index.html#string">string</a>) (*<a href="types.html#Package">Package</a>, <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ImporterFrom">type <a href="../../src/go/types/api.go%3Fs=2686:3368.html#L63">ImporterFrom</a>
				<a class="permalink" href="types.html#ImporterFrom">&#xb6;</a>
			</h2>
			<p>
An ImporterFrom resolves import paths to packages; it
supports vendoring per <a href="https://golang.org/s/go15vendor">https://golang.org/s/go15vendor</a>.
Use go/importer to obtain an ImporterFrom implementation.
</p>

			<pre>type ImporterFrom interface {
    <span class="comment">// Importer is present for backward-compatibility. Calling</span>
    <span class="comment">// Import(path) is the same as calling ImportFrom(path, &#34;&#34;, 0);</span>
    <span class="comment">// i.e., locally vendored packages may not be found.</span>
    <span class="comment">// The types package does not call Import if an ImporterFrom</span>
    <span class="comment">// is present.</span>
    <a href="types.html#Importer">Importer</a>

    <span class="comment">// ImportFrom returns the imported package for the given import</span>
    <span class="comment">// path when imported by the package in srcDir, or an error</span>
    <span class="comment">// if the package couldn&#39;t be imported. The mode value must</span>
    <span class="comment">// be 0; it is reserved for future use.</span>
    <span class="comment">// Two calls to ImportFrom with the same path and srcDir return</span>
    <span class="comment">// the same package.</span>
    ImportFrom(path, srcDir <a href="../builtin/index.html#string">string</a>, mode <a href="types.html#ImportMode">ImportMode</a>) (*<a href="types.html#Package">Package</a>, <a href="../builtin/index.html#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Info">type <a href="../../src/go/types/api.go%3Fs=5198:8680.html#L126">Info</a>
				<a class="permalink" href="types.html#Info">&#xb6;</a>
			</h2>
			<p>
Info holds result type information for a type-checked package.
Only the information for which a map is provided is collected.
If the package has type errors, the collected information may
be incomplete.
</p>

			<pre>type Info struct {
<span id="Info.Types"></span>    <span class="comment">// Types maps expressions to their types, and for constant</span>
    <span class="comment">// expressions, also their values. Invalid expressions are</span>
    <span class="comment">// omitted.</span>
    <span class="comment">//</span>
    <span class="comment">// For (possibly parenthesized) identifiers denoting built-in</span>
    <span class="comment">// functions, the recorded signatures are call-site specific:</span>
    <span class="comment">// if the call result is not a constant, the recorded type is</span>
    <span class="comment">// an argument-specific signature. Otherwise, the recorded type</span>
    <span class="comment">// is invalid.</span>
    <span class="comment">//</span>
    <span class="comment">// The Types map does not record the type of every identifier,</span>
    <span class="comment">// only those that appear where an arbitrary expression is</span>
    <span class="comment">// permitted. For instance, the identifier f in a selector</span>
    <span class="comment">// expression x.f is found only in the Selections map, the</span>
    <span class="comment">// identifier z in a variable declaration &#39;var z int&#39; is found</span>
    <span class="comment">// only in the Defs map, and identifiers denoting packages in</span>
    <span class="comment">// qualified identifiers are collected in the Uses map.</span>
    Types map[<a href="ast/index.html">ast</a>.<a href="ast/index.html#Expr">Expr</a>]<a href="types.html#TypeAndValue">TypeAndValue</a>

<span id="Info.Defs"></span>    <span class="comment">// Defs maps identifiers to the objects they define (including</span>
    <span class="comment">// package names, dots &#34;.&#34; of dot-imports, and blank &#34;_&#34; identifiers).</span>
    <span class="comment">// For identifiers that do not denote objects (e.g., the package name</span>
    <span class="comment">// in package clauses, or symbolic variables t in t := x.(type) of</span>
    <span class="comment">// type switch headers), the corresponding objects are nil.</span>
    <span class="comment">//</span>
    <span class="comment">// For an anonymous field, Defs returns the field *Var it defines.</span>
    <span class="comment">//</span>
    <span class="comment">// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()</span>
    Defs map[*<a href="ast/index.html">ast</a>.<a href="ast/index.html#Ident">Ident</a>]<a href="types.html#Object">Object</a>

<span id="Info.Uses"></span>    <span class="comment">// Uses maps identifiers to the objects they denote.</span>
    <span class="comment">//</span>
    <span class="comment">// For an anonymous field, Uses returns the *TypeName it denotes.</span>
    <span class="comment">//</span>
    <span class="comment">// Invariant: Uses[id].Pos() != id.Pos()</span>
    Uses map[*<a href="ast/index.html">ast</a>.<a href="ast/index.html#Ident">Ident</a>]<a href="types.html#Object">Object</a>

<span id="Info.Implicits"></span>    <span class="comment">// Implicits maps nodes to their implicitly declared objects, if any.</span>
    <span class="comment">// The following node and object types may appear:</span>
    <span class="comment">//</span>
    <span class="comment">//	node               declared object</span>
    <span class="comment">//</span>
    <span class="comment">//	*ast.ImportSpec    *PkgName for dot-imports and imports without renames</span>
    <span class="comment">//	*ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)</span>
    <span class="comment">//      *ast.Field         anonymous parameter *Var</span>
    <span class="comment">//</span>
    Implicits map[<a href="ast/index.html">ast</a>.<a href="ast/index.html#Node">Node</a>]<a href="types.html#Object">Object</a>

<span id="Info.Selections"></span>    <span class="comment">// Selections maps selector expressions (excluding qualified identifiers)</span>
    <span class="comment">// to their corresponding selections.</span>
    Selections map[*<a href="ast/index.html">ast</a>.<a href="ast/index.html#SelectorExpr">SelectorExpr</a>]*<a href="types.html#Selection">Selection</a>

<span id="Info.Scopes"></span>    <span class="comment">// Scopes maps ast.Nodes to the scopes they define. Package scopes are not</span>
    <span class="comment">// associated with a specific node but with all files belonging to a package.</span>
    <span class="comment">// Thus, the package scope can be found in the type-checked Package object.</span>
    <span class="comment">// Scopes nest, with the Universe scope being the outermost scope, enclosing</span>
    <span class="comment">// the package scope, which contains (one or more) files scopes, which enclose</span>
    <span class="comment">// function scopes which in turn enclose statement and function literal scopes.</span>
    <span class="comment">// Note that even though package-level functions are declared in the package</span>
    <span class="comment">// scope, the function scopes are embedded in the file scope of the file</span>
    <span class="comment">// containing the function declaration.</span>
    <span class="comment">//</span>
    <span class="comment">// The following node types may appear in Scopes:</span>
    <span class="comment">//</span>
    <span class="comment">//	*ast.File</span>
    <span class="comment">//	*ast.FuncType</span>
    <span class="comment">//	*ast.BlockStmt</span>
    <span class="comment">//	*ast.IfStmt</span>
    <span class="comment">//	*ast.SwitchStmt</span>
    <span class="comment">//	*ast.TypeSwitchStmt</span>
    <span class="comment">//	*ast.CaseClause</span>
    <span class="comment">//	*ast.CommClause</span>
    <span class="comment">//	*ast.ForStmt</span>
    <span class="comment">//	*ast.RangeStmt</span>
    <span class="comment">//</span>
    Scopes map[<a href="ast/index.html">ast</a>.<a href="ast/index.html#Node">Node</a>]*<a href="types.html#Scope">Scope</a>

<span id="Info.InitOrder"></span>    <span class="comment">// InitOrder is the list of package-level initializers in the order in which</span>
    <span class="comment">// they must be executed. Initializers referring to variables related by an</span>
    <span class="comment">// initialization dependency appear in topological order, the others appear</span>
    <span class="comment">// in source order. Variables without an initialization expression do not</span>
    <span class="comment">// appear in this list.</span>
    InitOrder []*<a href="types.html#Initializer">Initializer</a>
}</pre>

			

			

			<div id="example_Info" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>ExampleInfo prints various facts recorded by the type checker in a
types.Info struct: definitions of and references to each named object,
and the type, value, and mode of every expression in the package.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Parse a single source file.</span>
const input = `
package fib

type S string

var a, b, c = len(b), S(c), &#34;hello&#34;

func fib(x int) int {
if x &lt; 2 {
    return x
}
return fib(x-1) - fib(x-2)
}`
fset := token.NewFileSet()
f, err := parser.ParseFile(fset, &#34;fib.go&#34;, input, 0)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Type-check the package.</span>
<span class="comment">// We create an empty map for each kind of input</span>
<span class="comment">// we&#39;re interested in, and Check populates them.</span>
info := types.Info{
    Types: make(map[ast.Expr]types.TypeAndValue),
    Defs:  make(map[*ast.Ident]types.Object),
    Uses:  make(map[*ast.Ident]types.Object),
}
var conf types.Config
pkg, err := conf.Check(&#34;fib&#34;, fset, []*ast.File{f}, &amp;info)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Print package-level variables in initialization order.</span>
fmt.Printf(&#34;InitOrder: %v\n\n&#34;, info.InitOrder)

<span class="comment">// For each named object, print the line and</span>
<span class="comment">// column of its definition and each of its uses.</span>
fmt.Println(&#34;Defs and Uses of each named object:&#34;)
usesByObj := make(map[types.Object][]string)
for id, obj := range info.Uses {
    posn := fset.Position(id.Pos())
    lineCol := fmt.Sprintf(&#34;%d:%d&#34;, posn.Line, posn.Column)
    usesByObj[obj] = append(usesByObj[obj], lineCol)
}
var items []string
for obj, uses := range usesByObj {
    sort.Strings(uses)
    item := fmt.Sprintf(&#34;%s:\n  defined at %s\n  used at %s&#34;,
        types.ObjectString(obj, types.RelativeTo(pkg)),
        fset.Position(obj.Pos()),
        strings.Join(uses, &#34;, &#34;))
    items = append(items, item)
}
sort.Strings(items) <span class="comment">// sort by line:col, in effect</span>
fmt.Println(strings.Join(items, &#34;\n&#34;))
fmt.Println()

fmt.Println(&#34;Types and Values of each expression:&#34;)
items = nil
for expr, tv := range info.Types {
    var buf bytes.Buffer
    posn := fset.Position(expr.Pos())
    tvstr := tv.Type.String()
    if tv.Value != nil {
        tvstr += &#34; = &#34; + tv.Value.String()
    }
    <span class="comment">// line:col | expr | mode : type = value</span>
    fmt.Fprintf(&amp;buf, &#34;%2d:%2d | %-19s | %-7s : %s&#34;,
        posn.Line, posn.Column, exprString(fset, expr),
        mode(tv), tvstr)
    items = append(items, buf.String())
}
sort.Strings(items)
fmt.Println(strings.Join(items, &#34;\n&#34;))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">InitOrder: [c = &#34;hello&#34; b = S(c) a = len(b)]

Defs and Uses of each named object:
builtin len:
  defined at -
  used at 6:15
func fib(x int) int:
  defined at fib.go:8:6
  used at 12:20, 12:9
type S string:
  defined at fib.go:4:6
  used at 6:23
type int int:
  defined at -
  used at 8:12, 8:17
type string string:
  defined at -
  used at 4:8
var b S:
  defined at fib.go:6:8
  used at 6:19
var c string:
  defined at fib.go:6:11
  used at 6:25
var x int:
  defined at fib.go:8:10
  used at 10:10, 12:13, 12:24, 9:5

Types and Values of each expression:
 4: 8 | string              | type    : string
 6:15 | len                 | builtin : func(string) int
 6:15 | len(b)              | value   : int
 6:19 | b                   | var     : fib.S
 6:23 | S                   | type    : fib.S
 6:23 | S(c)                | value   : fib.S
 6:25 | c                   | var     : string
 6:29 | &#34;hello&#34;             | value   : string = &#34;hello&#34;
 8:12 | int                 | type    : int
 8:17 | int                 | type    : int
 9: 5 | x                   | var     : int
 9: 5 | x &lt; 2               | value   : untyped bool
 9: 9 | 2                   | value   : int = 2
10:10 | x                   | var     : int
12: 9 | fib                 | value   : func(x int) int
12: 9 | fib(x - 1)          | value   : int
12: 9 | fib(x-1) - fib(x-2) | value   : int
12:13 | x                   | var     : int
12:13 | x - 1               | value   : int
12:15 | 1                   | value   : int = 1
12:20 | fib                 | value   : func(x int) int
12:20 | fib(x - 2)          | value   : int
12:24 | x                   | var     : int
12:24 | x - 2               | value   : int
12:26 | 2                   | value   : int = 2
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Info.ObjectOf">func (*Info) <a href="../../src/go/types/api.go%3Fs=9306:9354.html#L235">ObjectOf</a>
					<a class="permalink" href="types.html#Info.ObjectOf">&#xb6;</a>
				</h3>
				<pre>func (info *<a href="types.html#Info">Info</a>) ObjectOf(id *<a href="ast/index.html">ast</a>.<a href="ast/index.html#Ident">Ident</a>) <a href="types.html#Object">Object</a></pre>
				<p>
ObjectOf returns the object denoted by the specified id,
or nil if not found.
</p>
<p>
If id is an anonymous struct field, ObjectOf returns the field (*Var)
it uses, not the type (*TypeName) it defines.
</p>
<p>
Precondition: the Uses and Defs maps are populated.
</p>

				
				
				
			
				
				<h3 id="Info.TypeOf">func (*Info) <a href="../../src/go/types/api.go%3Fs=8812:8853.html#L215">TypeOf</a>
					<a class="permalink" href="types.html#Info.TypeOf">&#xb6;</a>
				</h3>
				<pre>func (info *<a href="types.html#Info">Info</a>) TypeOf(e <a href="ast/index.html">ast</a>.<a href="ast/index.html#Expr">Expr</a>) <a href="types.html#Type">Type</a></pre>
				<p>
TypeOf returns the type of expression e, or nil if not found.
Precondition: the Types, Uses and Defs maps are populated.
</p>

				
				
				
			
		
			
			
			<h2 id="Initializer">type <a href="../../src/go/types/api.go%3Fs=11529:11599.html#L308">Initializer</a>
				<a class="permalink" href="types.html#Initializer">&#xb6;</a>
			</h2>
			<p>
An Initializer describes a package-level variable, or a list of variables in case
of a multi-valued initialization expression, and the corresponding initialization
expression.
</p>

			<pre>type Initializer struct {
<span id="Initializer.Lhs"></span>    Lhs []*<a href="types.html#Var">Var</a> <span class="comment">// var Lhs = Rhs</span>
<span id="Initializer.Rhs"></span>    Rhs <a href="ast/index.html">ast</a>.<a href="ast/index.html#Expr">Expr</a>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="Initializer.String">func (*Initializer) <a href="../../src/go/types/api.go%3Fs=11601:11641.html#L313">String</a>
					<a class="permalink" href="types.html#Initializer.String">&#xb6;</a>
				</h3>
				<pre>func (init *<a href="types.html#Initializer">Initializer</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Interface">type <a href="../../src/go/types/type.go%3Fs=6679:6959.html#L231">Interface</a>
				<a class="permalink" href="types.html#Interface">&#xb6;</a>
			</h2>
			<p>
An Interface represents an interface type.
</p>

			<pre>type Interface struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewInterface">func <a href="../../src/go/types/type.go%3Fs=7043:7108.html#L239">NewInterface</a>
					<a class="permalink" href="types.html#NewInterface">&#xb6;</a>
				</h3>
				<pre>func NewInterface(methods []*<a href="types.html#Func">Func</a>, embeddeds []*<a href="types.html#Named">Named</a>) *<a href="types.html#Interface">Interface</a></pre>
				<p>
NewInterface returns a new interface for the given methods and embedded types.
</p>

				
				
			

			
				
				<h3 id="Interface.Complete">func (*Interface) <a href="../../src/go/types/type.go%3Fs=9119:9160.html#L291">Complete</a>
					<a class="permalink" href="types.html#Interface.Complete">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) Complete() *<a href="types.html#Interface">Interface</a></pre>
				<p>
Complete computes the interface&#39;s method set. It must be called by users of
NewInterface after the interface&#39;s embedded types are fully defined and
before using the interface type in any way other than to form other types.
Complete returns the receiver.
</p>

				
				
				
			
				
				<h3 id="Interface.Embedded">func (*Interface) <a href="../../src/go/types/type.go%3Fs=8338:8380.html#L275">Embedded</a>
					<a class="permalink" href="types.html#Interface.Embedded">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) Embedded(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Named">Named</a></pre>
				<p>
Embedded returns the i&#39;th embedded type of interface t for 0 &lt;= i &lt; t.NumEmbeddeds().
The types are ordered by the corresponding TypeName&#39;s unique Id.
</p>

				
				
				
			
				
				<h3 id="Interface.Empty">func (*Interface) <a href="../../src/go/types/type.go%3Fs=8785:8817.html#L285">Empty</a>
					<a class="permalink" href="types.html#Interface.Empty">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) Empty() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
Empty returns true if t is the empty interface.
</p>

				
				
				
			
				
				<h3 id="Interface.ExplicitMethod">func (*Interface) <a href="../../src/go/types/type.go%3Fs=7971:8018.html#L268">ExplicitMethod</a>
					<a class="permalink" href="types.html#Interface.ExplicitMethod">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) ExplicitMethod(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Func">Func</a></pre>
				<p>
ExplicitMethod returns the i&#39;th explicitly declared method of interface t for 0 &lt;= i &lt; t.NumExplicitMethods().
The methods are ordered by their unique Id.
</p>

				
				
				
			
				
				<h3 id="Interface.Method">func (*Interface) <a href="../../src/go/types/type.go%3Fs=8666:8705.html#L282">Method</a>
					<a class="permalink" href="types.html#Interface.Method">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) Method(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Func">Func</a></pre>
				<p>
Method returns the i&#39;th method of interface t for 0 &lt;= i &lt; t.NumMethods().
The methods are ordered by their unique Id.
</p>

				
				
				
			
				
				<h3 id="Interface.NumEmbeddeds">func (*Interface) <a href="../../src/go/types/type.go%3Fs=8113:8151.html#L271">NumEmbeddeds</a>
					<a class="permalink" href="types.html#Interface.NumEmbeddeds">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) NumEmbeddeds() <a href="../builtin/index.html#int">int</a></pre>
				<p>
NumEmbeddeds returns the number of embedded types in interface t.
</p>

				
				
				
			
				
				<h3 id="Interface.NumExplicitMethods">func (*Interface) <a href="../../src/go/types/type.go%3Fs=7738:7782.html#L264">NumExplicitMethods</a>
					<a class="permalink" href="types.html#Interface.NumExplicitMethods">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) NumExplicitMethods() <a href="../builtin/index.html#int">int</a></pre>
				<p>
NumExplicitMethods returns the number of explicitly declared methods of interface t.
</p>

				
				
				
			
				
				<h3 id="Interface.NumMethods">func (*Interface) <a href="../../src/go/types/type.go%3Fs=8474:8510.html#L278">NumMethods</a>
					<a class="permalink" href="types.html#Interface.NumMethods">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) NumMethods() <a href="../builtin/index.html#int">int</a></pre>
				<p>
NumMethods returns the total number of methods of interface t.
</p>

				
				
				
			
				
				<h3 id="Interface.String">func (*Interface) <a href="../../src/go/types/type.go%3Fs=13783:13818.html#L437">String</a>
					<a class="permalink" href="types.html#Interface.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Interface.Underlying">func (*Interface) <a href="../../src/go/types/type.go%3Fs=13105:13142.html#L425">Underlying</a>
					<a class="permalink" href="types.html#Interface.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Interface">Interface</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Label">type <a href="../../src/go/types/object.go%3Fs=8346:8415.html#L231">Label</a>
				<a class="permalink" href="types.html#Label">&#xb6;</a>
			</h2>
			<p>
A Label represents a declared label.
</p>

			<pre>type Label struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewLabel">func <a href="../../src/go/types/object.go%3Fs=8417:8479.html#L236">NewLabel</a>
					<a class="permalink" href="types.html#NewLabel">&#xb6;</a>
				</h3>
				<pre>func NewLabel(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>) *<a href="types.html#Label">Label</a></pre>
				
				
				
			

			
				
				<h3 id="Label.Exported">func (*Label) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#Label.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Label.Id">func (*Label) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#Label.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Label.Name">func (*Label) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#Label.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Label.Parent">func (*Label) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#Label.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="Label.Pkg">func (*Label) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#Label.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Label.Pos">func (*Label) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#Label.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Label.String">func (*Label) <a href="../../src/go/types/object.go%3Fs=11065:11098.html#L352">String</a>
					<a class="permalink" href="types.html#Label.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Label.Type">func (*Label) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#Label.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Label">Label</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Map">type <a href="../../src/go/types/type.go%3Fs=9904:9939.html#L325">Map</a>
				<a class="permalink" href="types.html#Map">&#xb6;</a>
			</h2>
			<p>
A Map represents a map type.
</p>

			<pre>type Map struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewMap">func <a href="../../src/go/types/type.go%3Fs=10006:10038.html#L330">NewMap</a>
					<a class="permalink" href="types.html#NewMap">&#xb6;</a>
				</h3>
				<pre>func NewMap(key, elem <a href="types.html#Type">Type</a>) *<a href="types.html#Map">Map</a></pre>
				<p>
NewMap returns a new map for the given key and element types.
</p>

				
				
			

			
				
				<h3 id="Map.Elem">func (*Map) <a href="../../src/go/types/type.go%3Fs=10192:10217.html#L338">Elem</a>
					<a class="permalink" href="types.html#Map.Elem">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="types.html#Map">Map</a>) Elem() <a href="types.html#Type">Type</a></pre>
				<p>
Elem returns the element type of map m.
</p>

				
				
				
			
				
				<h3 id="Map.Key">func (*Map) <a href="../../src/go/types/type.go%3Fs=10106:10130.html#L335">Key</a>
					<a class="permalink" href="types.html#Map.Key">&#xb6;</a>
				</h3>
				<pre>func (m *<a href="types.html#Map">Map</a>) Key() <a href="types.html#Type">Type</a></pre>
				<p>
Key returns the key type of map m.
</p>

				
				
				
			
				
				<h3 id="Map.String">func (*Map) <a href="../../src/go/types/type.go%3Fs=13849:13878.html#L438">String</a>
					<a class="permalink" href="types.html#Map.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Map">Map</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Map.Underlying">func (*Map) <a href="../../src/go/types/type.go%3Fs=13156:13187.html#L426">Underlying</a>
					<a class="permalink" href="types.html#Map.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Map">Map</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MethodSet">type <a href="../../src/go/types/methodset.go%3Fs=483:527.html#L8">MethodSet</a>
				<a class="permalink" href="types.html#MethodSet">&#xb6;</a>
			</h2>
			<p>
A MethodSet is an ordered set of concrete or abstract (interface) methods;
a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id().
The zero value for a MethodSet is a ready-to-use empty method set.
</p>

			<pre>type MethodSet struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			<div id="example_MethodSet" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>ExampleMethodSet prints the method sets of various types.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Parse a single source file.</span>
const input = `
package temperature
import &#34;fmt&#34;
type Celsius float64
func (c Celsius) String() string  { return fmt.Sprintf(&#34;%g°C&#34;, c) }
func (c *Celsius) SetF(f float64) { *c = Celsius(f - 32 / 9 * 5) }
`
fset := token.NewFileSet()
f, err := parser.ParseFile(fset, &#34;celsius.go&#34;, input, 0)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Type-check a package consisting of this file.</span>
<span class="comment">// Type information for the imported packages</span>
<span class="comment">// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.</span>
conf := types.Config{Importer: importer.Default()}
pkg, err := conf.Check(&#34;temperature&#34;, fset, []*ast.File{f}, nil)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Print the method sets of Celsius and *Celsius.</span>
celsius := pkg.Scope().Lookup(&#34;Celsius&#34;).Type()
for _, t := range []types.Type{celsius, types.NewPointer(celsius)} {
    fmt.Printf(&#34;Method set of %s:\n&#34;, t)
    mset := types.NewMethodSet(t)
    for i := 0; i &lt; mset.Len(); i++ {
        fmt.Println(mset.At(i))
    }
    fmt.Println()
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Method set of temperature.Celsius:
method (temperature.Celsius) String() string

Method set of *temperature.Celsius:
method (*temperature.Celsius) SetF(f float64)
method (*temperature.Celsius) String() string
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewMethodSet">func <a href="../../src/go/types/methodset.go%3Fs=1587:1623.html#L57">NewMethodSet</a>
					<a class="permalink" href="types.html#NewMethodSet">&#xb6;</a>
				</h3>
				<pre>func NewMethodSet(T <a href="types.html#Type">Type</a>) *<a href="types.html#MethodSet">MethodSet</a></pre>
				<p>
NewMethodSet returns the method set for the given type T.
It always returns a non-nil method set, even if it is empty.
</p>

				
				
			

			
				
				<h3 id="MethodSet.At">func (*MethodSet) <a href="../../src/go/types/methodset.go%3Fs=938:978.html#L30">At</a>
					<a class="permalink" href="types.html#MethodSet.At">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#MethodSet">MethodSet</a>) At(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Selection">Selection</a></pre>
				<p>
At returns the i&#39;th method in s for 0 &lt;= i &lt; s.Len().
</p>

				
				
				
			
				
				<h3 id="MethodSet.Len">func (*MethodSet) <a href="../../src/go/types/methodset.go%3Fs=827:856.html#L27">Len</a>
					<a class="permalink" href="types.html#MethodSet.Len">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#MethodSet">MethodSet</a>) Len() <a href="../builtin/index.html#int">int</a></pre>
				<p>
Len returns the number of methods in s.
</p>

				
				
				
			
				
				<h3 id="MethodSet.Lookup">func (*MethodSet) <a href="../../src/go/types/methodset.go%3Fs=1083:1147.html#L33">Lookup</a>
					<a class="permalink" href="types.html#MethodSet.Lookup">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#MethodSet">MethodSet</a>) Lookup(pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>) *<a href="types.html#Selection">Selection</a></pre>
				<p>
Lookup returns the method with matching package and name, or nil if not found.
</p>

				
				
				
			
				
				<h3 id="MethodSet.String">func (*MethodSet) <a href="../../src/go/types/methodset.go%3Fs=529:564.html#L12">String</a>
					<a class="permalink" href="types.html#MethodSet.String">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#MethodSet">MethodSet</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Named">type <a href="../../src/go/types/type.go%3Fs=10887:11148.html#L368">Named</a>
				<a class="permalink" href="types.html#Named">&#xb6;</a>
			</h2>
			<p>
A Named represents a named type.
</p>

			<pre>type Named struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewNamed">func <a href="../../src/go/types/type.go%3Fs=11298:11367.html#L376">NewNamed</a>
					<a class="permalink" href="types.html#NewNamed">&#xb6;</a>
				</h3>
				<pre>func NewNamed(obj *<a href="types.html#TypeName">TypeName</a>, underlying <a href="types.html#Type">Type</a>, methods []*<a href="types.html#Func">Func</a>) *<a href="types.html#Named">Named</a></pre>
				<p>
NewNamed returns a new named type for the given type name, underlying type, and associated methods.
The underlying type must not be a *Named.
</p>

				
				
			

			
				
				<h3 id="Named.AddMethod">func (*Named) <a href="../../src/go/types/type.go%3Fs=12572:12606.html#L410">AddMethod</a>
					<a class="permalink" href="types.html#Named.AddMethod">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Named">Named</a>) AddMethod(m *<a href="types.html#Func">Func</a>)</pre>
				<p>
AddMethod adds method m unless it is already in the method list.
TODO(gri) find a better solution instead of providing this function
</p>

				
				
				
			
				
				<h3 id="Named.Method">func (*Named) <a href="../../src/go/types/type.go%3Fs=11926:11961.html#L394">Method</a>
					<a class="permalink" href="types.html#Named.Method">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Named">Named</a>) Method(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Func">Func</a></pre>
				<p>
Method returns the i&#39;th method of named type t for 0 &lt;= i &lt; t.NumMethods().
</p>

				
				
				
			
				
				<h3 id="Named.NumMethods">func (*Named) <a href="../../src/go/types/type.go%3Fs=11787:11819.html#L391">NumMethods</a>
					<a class="permalink" href="types.html#Named.NumMethods">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Named">Named</a>) NumMethods() <a href="../builtin/index.html#int">int</a></pre>
				<p>
NumMethods returns the number of explicit methods whose receiver is named type t.
</p>

				
				
				
			
				
				<h3 id="Named.Obj">func (*Named) <a href="../../src/go/types/type.go%3Fs=11652:11683.html#L388">Obj</a>
					<a class="permalink" href="types.html#Named.Obj">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Named">Named</a>) Obj() *<a href="types.html#TypeName">TypeName</a></pre>
				<p>
TypeName returns the type name for the named type t.
</p>

				
				
				
			
				
				<h3 id="Named.SetUnderlying">func (*Named) <a href="../../src/go/types/type.go%3Fs=12142:12188.html#L398">SetUnderlying</a>
					<a class="permalink" href="types.html#Named.SetUnderlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Named">Named</a>) SetUnderlying(underlying <a href="types.html#Type">Type</a>)</pre>
				<p>
SetUnderlying sets the underlying type and marks t as complete.
TODO(gri) determine if there&#39;s a better solution rather than providing this function
</p>

				
				
				
			
				
				<h3 id="Named.String">func (*Named) <a href="../../src/go/types/type.go%3Fs=13981:14012.html#L440">String</a>
					<a class="permalink" href="types.html#Named.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Named">Named</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Named.Underlying">func (*Named) <a href="../../src/go/types/type.go%3Fs=13258:13291.html#L428">Underlying</a>
					<a class="permalink" href="types.html#Named.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Named">Named</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Nil">type <a href="../../src/go/types/object.go%3Fs=8865:8892.html#L252">Nil</a>
				<a class="permalink" href="types.html#Nil">&#xb6;</a>
			</h2>
			<p>
Nil represents the predeclared value nil.
</p>

			<pre>type Nil struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="Nil.Exported">func (*Nil) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#Nil.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.Id">func (*Nil) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#Nil.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.Name">func (*Nil) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#Nil.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.Parent">func (*Nil) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#Nil.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.Pkg">func (*Nil) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#Nil.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.Pos">func (*Nil) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#Nil.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.String">func (*Nil) <a href="../../src/go/types/object.go%3Fs=11217:11248.html#L354">String</a>
					<a class="permalink" href="types.html#Nil.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.Type">func (*Nil) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#Nil.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Nil">Nil</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Object">type <a href="../../src/go/types/object.go%3Fs=501:1767.html#L11">Object</a>
				<a class="permalink" href="types.html#Object">&#xb6;</a>
			</h2>
			<p>
An Object describes a named language entity such as a package,
constant, type, variable, function (incl. methods), or label.
All objects implement the Object interface.
</p>

			<pre>type Object interface {
    Parent() *<a href="types.html#Scope">Scope</a> <span class="comment">// scope in which this object is declared; nil for methods and struct fields</span>
    Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a> <span class="comment">// position of object identifier in declaration</span>
    Pkg() *<a href="types.html#Package">Package</a>  <span class="comment">// nil for objects in the Universe scope and labels</span>
    Name() <a href="../builtin/index.html#string">string</a>   <span class="comment">// package local object name</span>
    Type() <a href="types.html#Type">Type</a>     <span class="comment">// object type</span>
    Exported() <a href="../builtin/index.html#bool">bool</a> <span class="comment">// reports whether the name starts with a capital letter</span>
    Id() <a href="../builtin/index.html#string">string</a>     <span class="comment">// object id (see Id below)</span>

    <span class="comment">// String returns a human-readable string of the object.</span>
    String() <a href="../builtin/index.html#string">string</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="LookupFieldOrMethod">func <a href="../../src/go/types/lookup.go%3Fs=1550:1668.html#L25">LookupFieldOrMethod</a>
					<a class="permalink" href="types.html#LookupFieldOrMethod">&#xb6;</a>
				</h3>
				<pre>func LookupFieldOrMethod(T <a href="types.html#Type">Type</a>, addressable <a href="../builtin/index.html#bool">bool</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>) (obj <a href="types.html#Object">Object</a>, index []<a href="../builtin/index.html#int">int</a>, indirect <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>
LookupFieldOrMethod looks up a field or method with given package and name
in T and returns the corresponding *Var or *Func, an index sequence, and a
bool indicating if there were any pointer indirections on the path to the
field or method. If addressable is set, T is the type of an addressable
variable (only matters for method lookups).
</p>
<p>
The last index entry is the field or method index in the (possibly embedded)
type where the entry was found, either:
</p>
<pre>1) the list of declared methods of a named type; or
2) the list of all methods (method set) of an interface type; or
3) the list of fields of a struct type.
</pre>
<p>
The earlier index entries are the indices of the anonymous struct fields
traversed to get to the found entry, starting at depth 0.
</p>
<p>
If no entry is found, a nil object is returned. In this case, the returned
index and indirect values have the following meaning:
</p>
<pre>	- If index != nil, the index sequence points to an ambiguous entry
	(the same name appeared more than once at the same embedding level).

	- If indirect is set, a method with a pointer receiver type was found
     but there was no pointer on the path from the actual receiver type to
	the method&#39;s formal receiver base type, nor was the receiver addressable.
</pre>

				
				
			

			
		
			
			
			<h2 id="Package">type <a href="../../src/go/types/package.go%3Fs=243:451.html#L3">Package</a>
				<a class="permalink" href="types.html#Package">&#xb6;</a>
			</h2>
			<p>
A Package describes a Go package.
</p>

			<pre>type Package struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewPackage">func <a href="../../src/go/types/package.go%3Fs=637:680.html#L15">NewPackage</a>
					<a class="permalink" href="types.html#NewPackage">&#xb6;</a>
				</h3>
				<pre>func NewPackage(path, name <a href="../builtin/index.html#string">string</a>) *<a href="types.html#Package">Package</a></pre>
				<p>
NewPackage returns a new Package for the given package path and name;
the name must not be the blank identifier.
The package is not complete and contains no explicit imports.
</p>

				
				
			

			
				
				<h3 id="Package.Complete">func (*Package) <a href="../../src/go/types/package.go%3Fs=1476:1511.html#L39">Complete</a>
					<a class="permalink" href="types.html#Package.Complete">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) Complete() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
A package is complete if its scope contains (at least) all
exported objects; otherwise it is incomplete.
</p>

				
				
				
			
				
				<h3 id="Package.Imports">func (*Package) <a href="../../src/go/types/package.go%3Fs=1986:2026.html#L50">Imports</a>
					<a class="permalink" href="types.html#Package.Imports">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) Imports() []*<a href="types.html#Package">Package</a></pre>
				<p>
Imports returns the list of packages directly imported by
pkg; the list is in source order. Package unsafe is excluded.
</p>
<p>
If pkg was loaded from export data, Imports includes packages that
provide package-level objects referenced by pkg. This may be more or
less than the set of packages directly imported by pkg&#39;s source code.
</p>

				
				
				
			
				
				<h3 id="Package.MarkComplete">func (*Package) <a href="../../src/go/types/package.go%3Fs=1582:1616.html#L42">MarkComplete</a>
					<a class="permalink" href="types.html#Package.MarkComplete">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) MarkComplete()</pre>
				<p>
MarkComplete marks a package as complete.
</p>

				
				
				
			
				
				<h3 id="Package.Name">func (*Package) <a href="../../src/go/types/package.go%3Fs=1007:1040.html#L27">Name</a>
					<a class="permalink" href="types.html#Package.Name">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				<p>
Name returns the package name.
</p>

				
				
				
			
				
				<h3 id="Package.Path">func (*Package) <a href="../../src/go/types/package.go%3Fs=918:951.html#L24">Path</a>
					<a class="permalink" href="types.html#Package.Path">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) Path() <a href="../builtin/index.html#string">string</a></pre>
				<p>
Path returns the package path.
</p>

				
				
				
			
				
				<h3 id="Package.Scope">func (*Package) <a href="../../src/go/types/package.go%3Fs=1308:1342.html#L35">Scope</a>
					<a class="permalink" href="types.html#Package.Scope">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) Scope() *<a href="types.html#Scope">Scope</a></pre>
				<p>
Scope returns the (complete or incomplete) package scope
holding the objects declared at package level (TypeNames,
Consts, Vars, and Funcs).
</p>

				
				
				
			
				
				<h3 id="Package.SetImports">func (*Package) <a href="../../src/go/types/package.go%3Fs=2196:2243.html#L54">SetImports</a>
					<a class="permalink" href="types.html#Package.SetImports">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) SetImports(list []*<a href="types.html#Package">Package</a>)</pre>
				<p>
SetImports sets the list of explicitly imported packages to list.
It is the caller&#39;s responsibility to make sure list elements are unique.
</p>

				
				
				
			
				
				<h3 id="Package.SetName">func (*Package) <a href="../../src/go/types/package.go%3Fs=1096:1136.html#L30">SetName</a>
					<a class="permalink" href="types.html#Package.SetName">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) SetName(name <a href="../builtin/index.html#string">string</a>)</pre>
				<p>
SetName sets the package name.
</p>

				
				
				
			
				
				<h3 id="Package.String">func (*Package) <a href="../../src/go/types/package.go%3Fs=2268:2303.html#L56">String</a>
					<a class="permalink" href="types.html#Package.String">&#xb6;</a>
				</h3>
				<pre>func (pkg *<a href="types.html#Package">Package</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PkgName">type <a href="../../src/go/types/object.go%3Fs=4243:4339.html#L119">PkgName</a>
				<a class="permalink" href="types.html#PkgName">&#xb6;</a>
			</h2>
			<p>
A PkgName represents an imported Go package.
</p>

			<pre>type PkgName struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewPkgName">func <a href="../../src/go/types/object.go%3Fs=4341:4426.html#L125">NewPkgName</a>
					<a class="permalink" href="types.html#NewPkgName">&#xb6;</a>
				</h3>
				<pre>func NewPkgName(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>, imported *<a href="types.html#Package">Package</a>) *<a href="types.html#PkgName">PkgName</a></pre>
				
				
				
			

			
				
				<h3 id="PkgName.Exported">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#PkgName.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.Id">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#PkgName.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.Imported">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=4660:4699.html#L131">Imported</a>
					<a class="permalink" href="types.html#PkgName.Imported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Imported() *<a href="types.html#Package">Package</a></pre>
				<p>
Imported returns the package that was imported.
It is distinct from Pkg(), which is the package containing the import statement.
</p>

				
				
				
			
				
				<h3 id="PkgName.Name">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#PkgName.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.Parent">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#PkgName.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.Pkg">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#PkgName.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.Pos">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#PkgName.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.String">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=10609:10644.html#L346">String</a>
					<a class="permalink" href="types.html#PkgName.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.Type">func (*PkgName) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#PkgName.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#PkgName">PkgName</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Pointer">type <a href="../../src/go/types/type.go%3Fs=3572:3622.html#L147">Pointer</a>
				<a class="permalink" href="types.html#Pointer">&#xb6;</a>
			</h2>
			<p>
A Pointer represents a pointer type.
</p>

			<pre>type Pointer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewPointer">func <a href="../../src/go/types/type.go%3Fs=3700:3735.html#L152">NewPointer</a>
					<a class="permalink" href="types.html#NewPointer">&#xb6;</a>
				</h3>
				<pre>func NewPointer(elem <a href="types.html#Type">Type</a>) *<a href="types.html#Pointer">Pointer</a></pre>
				<p>
NewPointer returns a new pointer type for the given element (base) type.
</p>

				
				
			

			
				
				<h3 id="Pointer.Elem">func (*Pointer) <a href="../../src/go/types/type.go%3Fs=3827:3856.html#L155">Elem</a>
					<a class="permalink" href="types.html#Pointer.Elem">&#xb6;</a>
				</h3>
				<pre>func (p *<a href="types.html#Pointer">Pointer</a>) Elem() <a href="types.html#Type">Type</a></pre>
				<p>
Elem returns the element type for the given pointer p.
</p>

				
				
				
			
				
				<h3 id="Pointer.String">func (*Pointer) <a href="../../src/go/types/type.go%3Fs=13585:13618.html#L434">String</a>
					<a class="permalink" href="types.html#Pointer.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Pointer">Pointer</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Pointer.Underlying">func (*Pointer) <a href="../../src/go/types/type.go%3Fs=12952:12987.html#L422">Underlying</a>
					<a class="permalink" href="types.html#Pointer.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Pointer">Pointer</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Qualifier">type <a href="../../src/go/types/typestring.go%3Fs=781:817.html#L15">Qualifier</a>
				<a class="permalink" href="types.html#Qualifier">&#xb6;</a>
			</h2>
			<p>
A Qualifier controls how named package-level objects are printed in
calls to TypeString, ObjectString, and SelectionString.
</p>
<p>
These three formatting routines call the Qualifier for each
package-level object O, and if the Qualifier returns a non-empty
string p, the object is printed in the form p.O.
If it returns an empty string, only the object name O is printed.
</p>
<p>
Using a nil Qualifier is equivalent to using (*Package).Path: the
object is qualified by the import path, e.g., &#34;encoding/json.Marshal&#34;.
</p>

			<pre>type Qualifier func(*<a href="types.html#Package">Package</a>) <a href="../builtin/index.html#string">string</a></pre>

			

			

			
			
			

			
				
				<h3 id="RelativeTo">func <a href="../../src/go/types/typestring.go%3Fs=922:961.html#L19">RelativeTo</a>
					<a class="permalink" href="types.html#RelativeTo">&#xb6;</a>
				</h3>
				<pre>func RelativeTo(pkg *<a href="types.html#Package">Package</a>) <a href="types.html#Qualifier">Qualifier</a></pre>
				<p>
RelativeTo(pkg) returns a Qualifier that fully qualifies members of
all packages other than pkg.
</p>

				
				
			

			
		
			
			
			<h2 id="Scope">type <a href="../../src/go/types/scope.go%3Fs=628:843.html#L15">Scope</a>
				<a class="permalink" href="types.html#Scope">&#xb6;</a>
			</h2>
			<p>
A Scope maintains a set of objects and links to its containing
(parent) and contained (children) scopes. Objects may be inserted
and looked up by name. The zero value for Scope is a ready-to-use
empty scope.
</p>

			<pre>type Scope struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			<div id="example_Scope" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>ExampleScope prints the tree of Scopes of a package created from a
set of parsed files.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Parse the source files for a package.</span>
fset := token.NewFileSet()
var files []*ast.File
for _, file := range []struct{ name, input string }{
    {&#34;main.go&#34;, `
package main
import &#34;fmt&#34;
func main() {
freezing := FToC(-18)
fmt.Println(freezing, Boiling) }
`},
    {&#34;celsius.go&#34;, `
package main
import &#34;fmt&#34;
type Celsius float64
func (c Celsius) String() string { return fmt.Sprintf(&#34;%g°C&#34;, c) }
func FToC(f float64) Celsius { return Celsius(f - 32 / 9 * 5) }
const Boiling Celsius = 100
`},
} {
    f, err := parser.ParseFile(fset, file.name, file.input, 0)
    if err != nil {
        log.Fatal(err)
    }
    files = append(files, f)
}

<span class="comment">// Type-check a package consisting of these files.</span>
<span class="comment">// Type information for the imported &#34;fmt&#34; package</span>
<span class="comment">// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.</span>
conf := types.Config{Importer: importer.Default()}
pkg, err := conf.Check(&#34;temperature&#34;, fset, files, nil)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Print the tree of scopes.</span>
<span class="comment">// For determinism, we redact addresses.</span>
var buf bytes.Buffer
pkg.Scope().WriteTo(&amp;buf, 0, true)
rx := regexp.MustCompile(` 0x[a-fA-F0-9]*`)
fmt.Println(rx.ReplaceAllString(buf.String(), &#34;&#34;))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">package &#34;temperature&#34; scope {
.  const temperature.Boiling temperature.Celsius
.  type temperature.Celsius float64
.  func temperature.FToC(f float64) temperature.Celsius
.  func temperature.main()

.  main.go scope {
.  .  package fmt

.  .  function scope {
.  .  .  var freezing temperature.Celsius
.  .  }.  }
.  celsius.go scope {
.  .  package fmt

.  .  function scope {
.  .  .  var c temperature.Celsius
.  .  }
.  .  function scope {
.  .  .  var f float64
.  .  }.  }}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewScope">func <a href="../../src/go/types/scope.go%3Fs=967:1038.html#L25">NewScope</a>
					<a class="permalink" href="types.html#NewScope">&#xb6;</a>
				</h3>
				<pre>func NewScope(parent *<a href="types.html#Scope">Scope</a>, pos, end <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, comment <a href="../builtin/index.html#string">string</a>) *<a href="types.html#Scope">Scope</a></pre>
				<p>
NewScope returns a new, empty scope contained in the given parent
scope, if any. The comment is for debugging only.
</p>

				
				
			

			
				
				<h3 id="Scope.Child">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=1869:1904.html#L56">Child</a>
					<a class="permalink" href="types.html#Scope.Child">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Child(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Scope">Scope</a></pre>
				<p>
Child returns the i&#39;th child scope for 0 &lt;= i &lt; NumChildren().
</p>

				
				
				
			
				
				<h3 id="Scope.Contains">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=4034:4078.html#L113">Contains</a>
					<a class="permalink" href="types.html#Scope.Contains">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Contains(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>) <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
Contains returns true if pos is within the scope&#39;s extent.
The result is guaranteed to be valid only if the type-checked
AST has complete position information.
</p>

				
				
				
			
				
				<h3 id="Scope.End">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=3815:3846.html#L108">End</a>
					<a class="permalink" href="types.html#Scope.End">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) End() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Scope.Innermost">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=4396:4443.html#L122">Innermost</a>
					<a class="permalink" href="types.html#Scope.Innermost">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Innermost(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>) *<a href="types.html#Scope">Scope</a></pre>
				<p>
Innermost returns the innermost (child) scope containing
pos. If pos is not within any scope, the result is nil.
The result is also nil for the Universe scope.
The result is guaranteed to be valid only if the type-checked
AST has complete position information.
</p>

				
				
				
			
				
				<h3 id="Scope.Insert">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=3267:3308.html#L88">Insert</a>
					<a class="permalink" href="types.html#Scope.Insert">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Insert(obj <a href="types.html#Object">Object</a>) <a href="types.html#Object">Object</a></pre>
				<p>
Insert attempts to insert an object obj into scope s.
If s already contains an alternative object alt with
the same name, Insert leaves s unchanged and returns alt.
Otherwise it inserts obj, sets the object&#39;s parent scope
if not already set, and returns nil.
</p>

				
				
				
			
				
				<h3 id="Scope.Len">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=1395:1420.html#L38">Len</a>
					<a class="permalink" href="types.html#Scope.Len">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Len() <a href="../builtin/index.html#int">int</a></pre>
				<p>
Len() returns the number of scope elements.
</p>

				
				
				
			
				
				<h3 id="Scope.Lookup">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=2049:2091.html#L60">Lookup</a>
					<a class="permalink" href="types.html#Scope.Lookup">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Lookup(name <a href="../builtin/index.html#string">string</a>) <a href="types.html#Object">Object</a></pre>
				<p>
Lookup returns the object in scope s with the given name if such an
object exists; otherwise the result is nil.
</p>

				
				
				
			
				
				<h3 id="Scope.LookupParent">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=2756:2829.html#L74">LookupParent</a>
					<a class="permalink" href="types.html#Scope.LookupParent">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) LookupParent(name <a href="../builtin/index.html#string">string</a>, pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>) (*<a href="types.html#Scope">Scope</a>, <a href="types.html#Object">Object</a>)</pre>
				<p>
LookupParent follows the parent chain of scopes starting with s until
it finds a scope where Lookup(name) returns a non-nil object, and then
returns that scope and object. If a valid position pos is provided,
only objects that were declared at or before pos are considered.
If no such scope and object exists, the result is (nil, nil).
</p>
<p>
Note that obj.Parent() may be different from the returned scope if the
object was inserted into the scope and already had a parent at that
time (see Insert, below). This can only happen for dot-imported objects
whose scope is the scope of the package that exported them.
</p>

				
				
				
			
				
				<h3 id="Scope.Names">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=1506:1538.html#L41">Names</a>
					<a class="permalink" href="types.html#Scope.Names">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Names() []<a href="../builtin/index.html#string">string</a></pre>
				<p>
Names returns the scope&#39;s element names in sorted order.
</p>

				
				
				
			
				
				<h3 id="Scope.NumChildren">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=1741:1774.html#L53">NumChildren</a>
					<a class="permalink" href="types.html#Scope.NumChildren">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) NumChildren() <a href="../builtin/index.html#int">int</a></pre>
				<p>
NumChildren() returns the number of scopes nested in s.
</p>

				
				
				
			
				
				<h3 id="Scope.Parent">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=1295:1326.html#L35">Parent</a>
					<a class="permalink" href="types.html#Scope.Parent">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				<p>
Parent returns the scope&#39;s containing (parent) scope.
</p>

				
				
				
			
				
				<h3 id="Scope.Pos">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=3766:3797.html#L107">Pos</a>
					<a class="permalink" href="types.html#Scope.Pos">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				<p>
Pos and End describe the scope&#39;s source code extent [pos, end).
The results are guaranteed to be valid only if the type-checked
AST has complete position information. The extent is undefined
for Universe and package scopes.
</p>

				
				
				
			
				
				<h3 id="Scope.String">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=5657:5688.html#L176">String</a>
					<a class="permalink" href="types.html#Scope.String">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				<p>
String returns a string representation of the scope, for debugging.
</p>

				
				
				
			
				
				<h3 id="Scope.WriteTo">func (*Scope) <a href="../../src/go/types/scope.go%3Fs=5097:5154.html#L149">WriteTo</a>
					<a class="permalink" href="types.html#Scope.WriteTo">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Scope">Scope</a>) WriteTo(w <a href="../io/index.html">io</a>.<a href="../io/index.html#Writer">Writer</a>, n <a href="../builtin/index.html#int">int</a>, recurse <a href="../builtin/index.html#bool">bool</a>)</pre>
				<p>
WriteTo writes a string representation of the scope to w,
with the scope elements sorted by name.
The level of indentation is controlled by n &gt;= 0, with
n == 0 for no indentation.
If recurse is set, it also writes nested (children) scopes.
</p>

				
				
				
			
		
			
			
			<h2 id="Selection">type <a href="../../src/go/types/selection.go%3Fs=1093:1326.html#L30">Selection</a>
				<a class="permalink" href="types.html#Selection">&#xb6;</a>
			</h2>
			<p>
A Selection describes a selector expression x.f.
For the declarations:
</p>
<pre>type T struct{ x int; E }
type E struct{}
func (e E) m() {}
var p *T
</pre>
<p>
the following relations exist:
</p>
<pre>Selector    Kind          Recv    Obj    Type               Index     Indirect

p.x         FieldVal      T       x      int                {0}       true
p.m         MethodVal     *T      m      func (e *T) m()    {1, 0}    true
T.m         MethodExpr    T       m      func m(_ T)        {1, 0}    false
</pre>

			<pre>type Selection struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="Selection.Index">func (*Selection) <a href="../../src/go/types/selection.go%3Fs=3090:3123.html#L92">Index</a>
					<a class="permalink" href="types.html#Selection.Index">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Selection">Selection</a>) Index() []<a href="../builtin/index.html#int">int</a></pre>
				<p>
Index describes the path from x to f in x.f.
The last index entry is the field or method index of the type declaring f;
either:
</p>
<pre>1) the list of declared methods of a named type; or
2) the list of methods of an interface type; or
3) the list of fields of a struct type.
</pre>
<p>
The earlier index entries are the indices of the embedded fields implicitly
traversed to get from (the type of) x to f, starting at embedding depth 0.
</p>

				
				
				
			
				
				<h3 id="Selection.Indirect">func (*Selection) <a href="../../src/go/types/selection.go%3Fs=3239:3274.html#L96">Indirect</a>
					<a class="permalink" href="types.html#Selection.Indirect">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Selection">Selection</a>) Indirect() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
Indirect reports whether any pointer indirection was required to get from
x to f in x.f.
</p>

				
				
				
			
				
				<h3 id="Selection.Kind">func (*Selection) <a href="../../src/go/types/selection.go%3Fs=1364:1404.html#L39">Kind</a>
					<a class="permalink" href="types.html#Selection.Kind">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Selection">Selection</a>) Kind() <a href="types.html#SelectionKind">SelectionKind</a></pre>
				<p>
Kind returns the selection kind.
</p>

				
				
				
			
				
				<h3 id="Selection.Obj">func (*Selection) <a href="../../src/go/types/selection.go%3Fs=1620:1652.html#L46">Obj</a>
					<a class="permalink" href="types.html#Selection.Obj">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Selection">Selection</a>) Obj() <a href="types.html#Object">Object</a></pre>
				<p>
Obj returns the object denoted by x.f; a *Var for
a field selection, and a *Func in all other cases.
</p>

				
				
				
			
				
				<h3 id="Selection.Recv">func (*Selection) <a href="../../src/go/types/selection.go%3Fs=1462:1493.html#L42">Recv</a>
					<a class="permalink" href="types.html#Selection.Recv">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Selection">Selection</a>) Recv() <a href="types.html#Type">Type</a></pre>
				<p>
Recv returns the type of x in x.f.
</p>

				
				
				
			
				
				<h3 id="Selection.String">func (*Selection) <a href="../../src/go/types/selection.go%3Fs=3298:3333.html#L98">String</a>
					<a class="permalink" href="types.html#Selection.String">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Selection">Selection</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Selection.Type">func (*Selection) <a href="../../src/go/types/selection.go%3Fs=1786:1817.html#L50">Type</a>
					<a class="permalink" href="types.html#Selection.Type">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Selection">Selection</a>) Type() <a href="types.html#Type">Type</a></pre>
				<p>
Type returns the type of x.f, which may be different from the type of f.
See Selection for more information.
</p>

				
				
				
			
		
			
			
			<h2 id="SelectionKind">type <a href="../../src/go/types/selection.go%3Fs=343:365.html#L6">SelectionKind</a>
				<a class="permalink" href="types.html#SelectionKind">&#xb6;</a>
			</h2>
			<p>
SelectionKind describes the kind of a selector expression x.f
(excluding qualified identifiers).
</p>

			<pre>type SelectionKind <a href="../builtin/index.html#int">int</a></pre>

			
				
				<pre>const (
    <span id="FieldVal">FieldVal</span>   <a href="types.html#SelectionKind">SelectionKind</a> = <a href="../builtin/index.html#iota">iota</a> <span class="comment">// x.f is a struct field selector</span>
    <span id="MethodVal">MethodVal</span>                       <span class="comment">// x.f is a method selector</span>
    <span id="MethodExpr">MethodExpr</span>                      <span class="comment">// x.f is a method expression</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Signature">type <a href="../../src/go/types/type.go%3Fs=4579:5262.html#L184">Signature</a>
				<a class="permalink" href="types.html#Signature">&#xb6;</a>
			</h2>
			<p>
A Signature represents a (non-builtin) function or method type.
</p>

			<pre>type Signature struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewSignature">func <a href="../../src/go/types/type.go%3Fs=5531:5609.html#L200">NewSignature</a>
					<a class="permalink" href="types.html#NewSignature">&#xb6;</a>
				</h3>
				<pre>func NewSignature(recv *<a href="types.html#Var">Var</a>, params, results *<a href="types.html#Tuple">Tuple</a>, variadic <a href="../builtin/index.html#bool">bool</a>) *<a href="types.html#Signature">Signature</a></pre>
				<p>
NewSignature returns a new function type for the given receiver, parameters,
and results, either of which may be nil. If variadic is set, the function
is variadic, it must have at least one parameter, and the last parameter
must be of unnamed slice type.
</p>

				
				
			

			
				
				<h3 id="Signature.Params">func (*Signature) <a href="../../src/go/types/type.go%3Fs=6346:6381.html#L222">Params</a>
					<a class="permalink" href="types.html#Signature.Params">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Signature">Signature</a>) Params() *<a href="types.html#Tuple">Tuple</a></pre>
				<p>
Params returns the parameters of signature s, or nil.
</p>

				
				
				
			
				
				<h3 id="Signature.Recv">func (*Signature) <a href="../../src/go/types/type.go%3Fs=6238:6269.html#L219">Recv</a>
					<a class="permalink" href="types.html#Signature.Recv">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Signature">Signature</a>) Recv() *<a href="types.html#Var">Var</a></pre>
				<p>
Recv returns the receiver of signature s (if a method), or nil if a
function.
</p>
<p>
For an abstract method, Recv returns the enclosing interface either
as a *Named or an *Interface. Due to embedding, an interface may
contain methods whose receiver type is a different interface.
</p>

				
				
				
			
				
				<h3 id="Signature.Results">func (*Signature) <a href="../../src/go/types/type.go%3Fs=6458:6494.html#L225">Results</a>
					<a class="permalink" href="types.html#Signature.Results">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Signature">Signature</a>) Results() *<a href="types.html#Tuple">Tuple</a></pre>
				<p>
Results returns the results of signature s, or nil.
</p>

				
				
				
			
				
				<h3 id="Signature.String">func (*Signature) <a href="../../src/go/types/type.go%3Fs=13717:13752.html#L436">String</a>
					<a class="permalink" href="types.html#Signature.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Signature">Signature</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Signature.Underlying">func (*Signature) <a href="../../src/go/types/type.go%3Fs=13054:13091.html#L424">Underlying</a>
					<a class="permalink" href="types.html#Signature.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Signature">Signature</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Signature.Variadic">func (*Signature) <a href="../../src/go/types/type.go%3Fs=6574:6609.html#L228">Variadic</a>
					<a class="permalink" href="types.html#Signature.Variadic">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Signature">Signature</a>) Variadic() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
Variadic reports whether the signature s is variadic.
</p>

				
				
				
			
		
			
			
			<h2 id="Sizes">type <a href="../../src/go/types/sizes.go%3Fs=265:769.html#L1">Sizes</a>
				<a class="permalink" href="types.html#Sizes">&#xb6;</a>
			</h2>
			<p>
Sizes defines the sizing functions for package unsafe.
</p>

			<pre>type Sizes interface {
    <span class="comment">// Alignof returns the alignment of a variable of type T.</span>
    <span class="comment">// Alignof must implement the alignment guarantees required by the spec.</span>
    Alignof(T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#int64">int64</a>

    <span class="comment">// Offsetsof returns the offsets of the given struct fields, in bytes.</span>
    <span class="comment">// Offsetsof must implement the offset guarantees required by the spec.</span>
    Offsetsof(fields []*<a href="types.html#Var">Var</a>) []<a href="../builtin/index.html#int64">int64</a>

    <span class="comment">// Sizeof returns the size of a variable of type T.</span>
    <span class="comment">// Sizeof must implement the size guarantees required by the spec.</span>
    Sizeof(T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#int64">int64</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Slice">type <a href="../../src/go/types/type.go%3Fs=2112:2144.html#L99">Slice</a>
				<a class="permalink" href="types.html#Slice">&#xb6;</a>
			</h2>
			<p>
A Slice represents a slice type.
</p>

			<pre>type Slice struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewSlice">func <a href="../../src/go/types/type.go%3Fs=2211:2242.html#L104">NewSlice</a>
					<a class="permalink" href="types.html#NewSlice">&#xb6;</a>
				</h3>
				<pre>func NewSlice(elem <a href="types.html#Type">Type</a>) *<a href="types.html#Slice">Slice</a></pre>
				<p>
NewSlice returns a new slice type for the given element type.
</p>

				
				
			

			
				
				<h3 id="Slice.Elem">func (*Slice) <a href="../../src/go/types/type.go%3Fs=2313:2340.html#L107">Elem</a>
					<a class="permalink" href="types.html#Slice.Elem">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Slice">Slice</a>) Elem() <a href="types.html#Type">Type</a></pre>
				<p>
Elem returns the element type of slice s.
</p>

				
				
				
			
				
				<h3 id="Slice.String">func (*Slice) <a href="../../src/go/types/type.go%3Fs=13453:13484.html#L432">String</a>
					<a class="permalink" href="types.html#Slice.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Slice">Slice</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Underlying">func (*Slice) <a href="../../src/go/types/type.go%3Fs=12850:12883.html#L420">Underlying</a>
					<a class="permalink" href="types.html#Slice.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Slice">Slice</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="StdSizes">type <a href="../../src/go/types/sizes.go%3Fs=1657:1804.html#L33">StdSizes</a>
				<a class="permalink" href="types.html#StdSizes">&#xb6;</a>
			</h2>
			<p>
StdSizes is a convenience type for creating commonly used Sizes.
It makes the following simplifying assumptions:
</p>
<pre>	- The size of explicitly sized basic types (int16, etc.) is the
	  specified size.
	- The size of strings and interfaces is 2*WordSize.
	- The size of slices is 3*WordSize.
	- The size of an array of n elements corresponds to the size of
	  a struct of n consecutive fields of the array&#39;s element type.
     - The size of a struct is the offset of the last field plus that
	  field&#39;s size. As with all element types, if the struct is used
	  in an array its size must first be aligned to a multiple of the
	  struct&#39;s alignment.
	- All other types have size WordSize.
	- Arrays and structs are aligned per spec definition; all other
	  types are naturally aligned with a maximum alignment MaxAlign.
</pre>
<p>
*StdSizes implements Sizes.
</p>

			<pre>type StdSizes struct {
<span id="StdSizes.WordSize"></span>    WordSize <a href="../builtin/index.html#int64">int64</a> <span class="comment">// word size in bytes - must be &gt;= 4 (32bits)</span>
<span id="StdSizes.MaxAlign"></span>    MaxAlign <a href="../builtin/index.html#int64">int64</a> <span class="comment">// maximum alignment in bytes - must be &gt;= 1</span>
}</pre>

			

			

			
			
			

			

			
				
				<h3 id="StdSizes.Alignof">func (*StdSizes) <a href="../../src/go/types/sizes.go%3Fs=1806:1846.html#L38">Alignof</a>
					<a class="permalink" href="types.html#StdSizes.Alignof">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#StdSizes">StdSizes</a>) Alignof(T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#int64">int64</a></pre>
				
				
				
				
			
				
				<h3 id="StdSizes.Offsetsof">func (*StdSizes) <a href="../../src/go/types/sizes.go%3Fs=3001:3052.html#L82">Offsetsof</a>
					<a class="permalink" href="types.html#StdSizes.Offsetsof">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#StdSizes">StdSizes</a>) Offsetsof(fields []*<a href="types.html#Var">Var</a>) []<a href="../builtin/index.html#int64">int64</a></pre>
				
				
				
				
			
				
				<h3 id="StdSizes.Sizeof">func (*StdSizes) <a href="../../src/go/types/sizes.go%3Fs=3479:3518.html#L110">Sizeof</a>
					<a class="permalink" href="types.html#StdSizes.Sizeof">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#StdSizes">StdSizes</a>) Sizeof(T <a href="types.html#Type">Type</a>) <a href="../builtin/index.html#int64">int64</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Struct">type <a href="../../src/go/types/type.go%3Fs=2398:2492.html#L110">Struct</a>
				<a class="permalink" href="types.html#Struct">&#xb6;</a>
			</h2>
			<p>
A Struct represents a struct type.
</p>

			<pre>type Struct struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewStruct">func <a href="../../src/go/types/type.go%3Fs=2792:2844.html#L119">NewStruct</a>
					<a class="permalink" href="types.html#NewStruct">&#xb6;</a>
				</h3>
				<pre>func NewStruct(fields []*<a href="types.html#Var">Var</a>, tags []<a href="../builtin/index.html#string">string</a>) *<a href="types.html#Struct">Struct</a></pre>
				<p>
NewStruct returns a new struct with the given fields and corresponding field tags.
If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be
only as long as required to hold the tag with the largest index i. Consequently,
if no field has a tag, tags may be nil.
</p>

				
				
			

			
				
				<h3 id="Struct.Field">func (*Struct) <a href="../../src/go/types/type.go%3Fs=3318:3352.html#L136">Field</a>
					<a class="permalink" href="types.html#Struct.Field">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Struct">Struct</a>) Field(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Var">Var</a></pre>
				<p>
Field returns the i&#39;th field for 0 &lt;= i &lt; NumFields().
</p>

				
				
				
			
				
				<h3 id="Struct.NumFields">func (*Struct) <a href="../../src/go/types/type.go%3Fs=3201:3233.html#L133">NumFields</a>
					<a class="permalink" href="types.html#Struct.NumFields">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Struct">Struct</a>) NumFields() <a href="../builtin/index.html#int">int</a></pre>
				<p>
NumFields returns the number of fields in the struct (including blank and anonymous fields).
</p>

				
				
				
			
				
				<h3 id="Struct.String">func (*Struct) <a href="../../src/go/types/type.go%3Fs=13519:13551.html#L433">String</a>
					<a class="permalink" href="types.html#Struct.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Struct">Struct</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Struct.Tag">func (*Struct) <a href="../../src/go/types/type.go%3Fs=3437:3471.html#L139">Tag</a>
					<a class="permalink" href="types.html#Struct.Tag">&#xb6;</a>
				</h3>
				<pre>func (s *<a href="types.html#Struct">Struct</a>) Tag(i <a href="../builtin/index.html#int">int</a>) <a href="../builtin/index.html#string">string</a></pre>
				<p>
Tag returns the i&#39;th field tag for 0 &lt;= i &lt; NumFields().
</p>

				
				
				
			
				
				<h3 id="Struct.Underlying">func (*Struct) <a href="../../src/go/types/type.go%3Fs=12901:12935.html#L421">Underlying</a>
					<a class="permalink" href="types.html#Struct.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Struct">Struct</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Tuple">type <a href="../../src/go/types/type.go%3Fs=4106:4140.html#L160">Tuple</a>
				<a class="permalink" href="types.html#Tuple">&#xb6;</a>
			</h2>
			<p>
A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple.
Tuples are used as components of signatures and to represent the type of multiple
assignments; they are not first class types of Go.
</p>

			<pre>type Tuple struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewTuple">func <a href="../../src/go/types/type.go%3Fs=4199:4230.html#L165">NewTuple</a>
					<a class="permalink" href="types.html#NewTuple">&#xb6;</a>
				</h3>
				<pre>func NewTuple(x ...*<a href="types.html#Var">Var</a>) *<a href="types.html#Tuple">Tuple</a></pre>
				<p>
NewTuple returns a new tuple for the given variables.
</p>

				
				
			

			
				
				<h3 id="Tuple.At">func (*Tuple) <a href="../../src/go/types/type.go%3Fs=4459:4489.html#L181">At</a>
					<a class="permalink" href="types.html#Tuple.At">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Tuple">Tuple</a>) At(i <a href="../builtin/index.html#int">int</a>) *<a href="types.html#Var">Var</a></pre>
				<p>
At returns the i&#39;th variable of tuple t.
</p>

				
				
				
			
				
				<h3 id="Tuple.Len">func (*Tuple) <a href="../../src/go/types/type.go%3Fs=4335:4360.html#L173">Len</a>
					<a class="permalink" href="types.html#Tuple.Len">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Tuple">Tuple</a>) Len() <a href="../builtin/index.html#int">int</a></pre>
				<p>
Len returns the number variables of tuple t.
</p>

				
				
				
			
				
				<h3 id="Tuple.String">func (*Tuple) <a href="../../src/go/types/type.go%3Fs=13651:13682.html#L435">String</a>
					<a class="permalink" href="types.html#Tuple.String">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Tuple">Tuple</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Tuple.Underlying">func (*Tuple) <a href="../../src/go/types/type.go%3Fs=13003:13036.html#L423">Underlying</a>
					<a class="permalink" href="types.html#Tuple.Underlying">&#xb6;</a>
				</h3>
				<pre>func (t *<a href="types.html#Tuple">Tuple</a>) Underlying() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Type">type <a href="../../src/go/types/type.go%3Fs=268:436.html#L1">Type</a>
				<a class="permalink" href="types.html#Type">&#xb6;</a>
			</h2>
			<p>
A Type represents a type of Go.
All types implement the Type interface.
</p>

			<pre>type Type interface {
    <span class="comment">// Underlying returns the underlying type of a type.</span>
    Underlying() <a href="types.html#Type">Type</a>

    <span class="comment">// String returns a string representation of a type.</span>
    String() <a href="../builtin/index.html#string">string</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Default">func <a href="../../src/go/types/predicates.go%3Fs=8065:8092.html#L288">Default</a>
					<a class="permalink" href="types.html#Default">&#xb6;</a>
				</h3>
				<pre>func Default(typ <a href="types.html#Type">Type</a>) <a href="types.html#Type">Type</a></pre>
				<p>
Default returns the default &#34;typed&#34; type for an &#34;untyped&#34; type;
it returns the incoming type for all other types. The default type
for untyped nil is untyped nil.
</p>

				
				
			

			
		
			
			
			<h2 id="TypeAndValue">type <a href="../../src/go/types/api.go%3Fs=9535:9616.html#L244">TypeAndValue</a>
				<a class="permalink" href="types.html#TypeAndValue">&#xb6;</a>
			</h2>
			<p>
TypeAndValue reports the type and value (for constants)
of the corresponding expression.
</p>

			<pre>type TypeAndValue struct {
<span id="TypeAndValue.Type"></span>    Type  <a href="types.html#Type">Type</a>
<span id="TypeAndValue.Value"></span>    Value <a href="constant/index.html">constant</a>.<a href="constant/index.html#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Eval">func <a href="../../src/go/types/eval.go%3Fs=1291:1385.html#L27">Eval</a>
					<a class="permalink" href="types.html#Eval">&#xb6;</a>
				</h3>
				<pre>func Eval(fset *<a href="token/index.html">token</a>.<a href="token/index.html#FileSet">FileSet</a>, pkg *<a href="types.html#Package">Package</a>, pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, expr <a href="../builtin/index.html#string">string</a>) (<a href="types.html#TypeAndValue">TypeAndValue</a>, <a href="../builtin/index.html#error">error</a>)</pre>
				<p>
Eval returns the type and, if constant, the value for the
expression expr, evaluated at position pos of package pkg,
which must have been derived from type-checking an AST with
complete position information relative to the provided file
set.
</p>
<p>
If the expression contains function literals, their bodies
are ignored (i.e., the bodies are not type-checked).
</p>
<p>
If pkg == nil, the Universe scope is used and the provided
position pos is ignored. If pkg != nil, and pos is invalid,
the package scope is used. Otherwise, pos must belong to the
package.
</p>
<p>
An error is returned if pos is not within the package or
if the node cannot be evaluated.
</p>
<p>
Note: Eval should not be used instead of running Check to compute
types and values, but in addition to Check. Eval will re-evaluate
its argument each time, and it also does not know about the context
in which an expression is used (e.g., an assignment). Thus, top-
level untyped constants will return an untyped type rather then the
respective context-specific type.
</p>

				
				
			

			
				
				<h3 id="TypeAndValue.Addressable">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=10858:10899.html#L289">Addressable</a>
					<a class="permalink" href="types.html#TypeAndValue.Addressable">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) Addressable() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
Addressable reports whether the corresponding expression
is addressable (<a href="https://golang.org/ref/spec#Address_operators">https://golang.org/ref/spec#Address_operators</a>).
</p>

				
				
				
			
				
				<h3 id="TypeAndValue.Assignable">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=11050:11090.html#L295">Assignable</a>
					<a class="permalink" href="types.html#TypeAndValue.Assignable">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) Assignable() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
Assignable reports whether the corresponding expression
is assignable to (provided a value of the right type).
</p>

				
				
				
			
				
				<h3 id="TypeAndValue.HasOk">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=11253:11288.html#L301">HasOk</a>
					<a class="permalink" href="types.html#TypeAndValue.HasOk">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) HasOk() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
HasOk reports whether the corresponding expression may be
used on the lhs of a comma-ok assignment.
</p>

				
				
				
			
				
				<h3 id="TypeAndValue.IsBuiltin">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=10177:10216.html#L266">IsBuiltin</a>
					<a class="permalink" href="types.html#TypeAndValue.IsBuiltin">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) IsBuiltin() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
IsBuiltin reports whether the corresponding expression denotes
a (possibly parenthesized) built-in function.
</p>

				
				
				
			
				
				<h3 id="TypeAndValue.IsNil">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=10635:10670.html#L283">IsNil</a>
					<a class="permalink" href="types.html#TypeAndValue.IsNil">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) IsNil() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
IsNil reports whether the corresponding expression denotes the
predeclared value nil.
</p>

				
				
				
			
				
				<h3 id="TypeAndValue.IsType">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=9993:10029.html#L260">IsType</a>
					<a class="permalink" href="types.html#TypeAndValue.IsType">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) IsType() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
IsType reports whether the corresponding expression specifies a type.
</p>

				
				
				
			
				
				<h3 id="TypeAndValue.IsValue">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=10398:10435.html#L273">IsValue</a>
					<a class="permalink" href="types.html#TypeAndValue.IsValue">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) IsValue() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
IsValue reports whether the corresponding expression is a value.
Builtins are not considered values. Constant values have a non-
nil Value.
</p>

				
				
				
			
				
				<h3 id="TypeAndValue.IsVoid">func (TypeAndValue) <a href="../../src/go/types/api.go%3Fs=9851:9887.html#L255">IsVoid</a>
					<a class="permalink" href="types.html#TypeAndValue.IsVoid">&#xb6;</a>
				</h3>
				<pre>func (tv <a href="types.html#TypeAndValue">TypeAndValue</a>) IsVoid() <a href="../builtin/index.html#bool">bool</a></pre>
				<p>
IsVoid reports whether the corresponding expression
is a function call without results.
</p>

				
				
				
			
		
			
			
			<h2 id="TypeName">type <a href="../../src/go/types/object.go%3Fs=5259:5291.html#L148">TypeName</a>
				<a class="permalink" href="types.html#TypeName">&#xb6;</a>
			</h2>
			<p>
A TypeName represents a declared type.
</p>

			<pre>type TypeName struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewTypeName">func <a href="../../src/go/types/object.go%3Fs=5293:5371.html#L152">NewTypeName</a>
					<a class="permalink" href="types.html#NewTypeName">&#xb6;</a>
				</h3>
				<pre>func NewTypeName(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>, typ <a href="types.html#Type">Type</a>) *<a href="types.html#TypeName">TypeName</a></pre>
				
				
				
			

			
				
				<h3 id="TypeName.Exported">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#TypeName.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.Id">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#TypeName.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.Name">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#TypeName.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.Parent">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#TypeName.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.Pkg">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#TypeName.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.Pos">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#TypeName.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.String">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=10761:10797.html#L348">String</a>
					<a class="permalink" href="types.html#TypeName.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.Type">func (*TypeName) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#TypeName.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#TypeName">TypeName</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Var">type <a href="../../src/go/types/object.go%3Fs=5554:5818.html#L157">Var</a>
				<a class="permalink" href="types.html#Var">&#xb6;</a>
			</h2>
			<p>
A Variable represents a declared variable (including function parameters and results, and struct fields).
</p>

			<pre>type Var struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="NewField">func <a href="../../src/go/types/object.go%3Fs=6156:6242.html#L173">NewField</a>
					<a class="permalink" href="types.html#NewField">&#xb6;</a>
				</h3>
				<pre>func NewField(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>, typ <a href="types.html#Type">Type</a>, anonymous <a href="../builtin/index.html#bool">bool</a>) *<a href="types.html#Var">Var</a></pre>
				
				
				
			
				
				<h3 id="NewParam">func <a href="../../src/go/types/object.go%3Fs=5965:6035.html#L169">NewParam</a>
					<a class="permalink" href="types.html#NewParam">&#xb6;</a>
				</h3>
				<pre>func NewParam(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>, typ <a href="types.html#Type">Type</a>) *<a href="types.html#Var">Var</a></pre>
				
				
				
			
				
				<h3 id="NewVar">func <a href="../../src/go/types/object.go%3Fs=5820:5888.html#L165">NewVar</a>
					<a class="permalink" href="types.html#NewVar">&#xb6;</a>
				</h3>
				<pre>func NewVar(pos <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a>, pkg *<a href="types.html#Package">Package</a>, name <a href="../builtin/index.html#string">string</a>, typ <a href="types.html#Type">Type</a>) *<a href="types.html#Var">Var</a></pre>
				
				
				
			

			
				
				<h3 id="Var.Anonymous">func (*Var) <a href="../../src/go/types/object.go%3Fs=6356:6388.html#L177">Anonymous</a>
					<a class="permalink" href="types.html#Var.Anonymous">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Anonymous() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Exported">func (*Var) <a href="../../src/go/types/object.go%3Fs=3008:3042.html#L86">Exported</a>
					<a class="permalink" href="types.html#Var.Exported">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Exported() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Id">func (*Var) <a href="../../src/go/types/object.go%3Fs=3084:3114.html#L87">Id</a>
					<a class="permalink" href="types.html#Var.Id">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Id() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Var.IsField">func (*Var) <a href="../../src/go/types/object.go%3Fs=6414:6444.html#L178">IsField</a>
					<a class="permalink" href="types.html#Var.IsField">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) IsField() <a href="../builtin/index.html#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Name">func (*Var) <a href="../../src/go/types/object.go%3Fs=2889:2921.html#L84">Name</a>
					<a class="permalink" href="types.html#Var.Name">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Name() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Parent">func (*Var) <a href="../../src/go/types/object.go%3Fs=2709:2743.html#L81">Parent</a>
					<a class="permalink" href="types.html#Var.Parent">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Parent() *<a href="types.html#Scope">Scope</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Pkg">func (*Var) <a href="../../src/go/types/object.go%3Fs=2830:2863.html#L83">Pkg</a>
					<a class="permalink" href="types.html#Var.Pkg">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Pkg() *<a href="types.html#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Pos">func (*Var) <a href="../../src/go/types/object.go%3Fs=2771:2805.html#L82">Pos</a>
					<a class="permalink" href="types.html#Var.Pos">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Pos() <a href="token/index.html">token</a>.<a href="token/index.html#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Var.String">func (*Var) <a href="../../src/go/types/object.go%3Fs=10837:10868.html#L349">String</a>
					<a class="permalink" href="types.html#Var.String">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) String() <a href="../builtin/index.html#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Type">func (*Var) <a href="../../src/go/types/object.go%3Fs=2949:2979.html#L85">Type</a>
					<a class="permalink" href="types.html#Var.Type">&#xb6;</a>
				</h3>
				<pre>func (obj *<a href="types.html#Var">Var</a>) Type() <a href="types.html#Type">Type</a></pre>
				
				
				
				
			
		
	

	







<div id="footer">
Build version go1.8.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="../../LICENSE.html">BSD license</a>.<br>
<a href="../../doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script type="text/javascript" src="/lib/godoc/jquery.js"></script>
<script type="text/javascript" src="/lib/godoc/jquery.treeview.js"></script>
<script type="text/javascript" src="/lib/godoc/jquery.treeview.edit.js"></script>


<script>var goVersion = "go1.8.5";</script>
<script type="text/javascript" src="/lib/godoc/godocs.js"></script>

</body>
</html>

